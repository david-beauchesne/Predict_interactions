# Predictive contribution of the algorithm, KNN algorithm to infer interactions#
        if(predict == 'full algorithm' | predict == 'predictive') {#
            for(i in S2) {#
                candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                    .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1
candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                    .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1
i
consumers <- KNN(taxa = i, matSim = consSim, K = K)
j
candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                        candLink(similar = ., K = K, candidates = candidates)
candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                        candLink(similar = ., candidates = candidates)
candidates
consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)
consumers
lapply(resources.S2, FUN = candLink, similar = KNN(taxa = X, matSim = resSim, K = K, minSim = minSim), candidates = candidates)
?lapply
is.vector(resources.S2)
resources.S2
lapply(resources.S2, FUN = candLink, similar = KNN(taxa = resources.S2, matSim = resSim, K = K, minSim = minSim), candidates = candidates)
lapply(as.list(resources.S2), FUN = candLink, similar = KNN(taxa = X, matSim = resSim, K = K, minSim = minSim), candidates = candidates)
for(j in resources.S2) {#
                        candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                        candLink(similar = ., candidates = candidates)#
                    }
candidates
consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)
consumers
candidate.resource <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j
candidate.resource
target <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j
target
target %in% S1
S1
target[which(target %in% S1)]
k
k = target[which(target %in% S1)
]
k
candidates <- candLink(similar = k, candidates = candidates) # REVIEW: Initial iteration of code, this step added 1 to the weight. Now it adds the weight.
candidates
similar
target[which(target %in% S1)]
S0[target[which(target %in% S1)], ]
resSim[target[which(target %in% S1)], ]
j
resSim[target[which(target %in% S1)], j]
resSim[j, target[which(target %in% S1)]]
similar
c(k,resSim[j, k])
candidates <- candLink(similar = c(k,resSim[j, k]), candidates = candidates) # REVIEW: Initial iteration of code, this step added 1 to the weight. Now it adds the weight.
candidates
consumer
target
consumers
similar
vector(1, )
vector(1 )
?c
numeric(1)
similar = 1
similar
similar <- 1 %>% names(.) %>% k
k
similar <- 1 %>% names(.) <- k
similar
names(similar) <- k
similar
candidates <- candLink(similar = , candidates = candidates) # REVIEW: Initial iteration of code, this step added 1 to the weight. Now it adds the weight.
candidates <- candLink(similar = similar, candidates = candidates) # REVIEW: Initial iteration of code, this step added 1 to the weight. Now it adds the weight.
similar
candidates
similar <- 1#
                                names(similar) <- k
similar
candidates
candidates <- candLink(similar = similar, candidates = candidates) # REVIEW: Initial iteration of code, this step added 1 to the weight. Now it adds the weight.
candidates
target[!which(target %in% S1)]
target
S1
!which(target %in% S1)
which(!target %in% S1)
target[which(!target %in% S1)]
candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                                candLink(similar = ., candidates = candidates)
candidates
k
for(k in target[which(!target %in% S1)]) { #
                                candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                                candLink(similar = ., candidates = candidates)#
                            }
candidates
k
KNN(taxa = k, matSim = resSim, K = K, minSim = minSim)
for(k in target[which(!target %in% S1)]) { #
                                candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                                candLink(similar = ., candidates = candidates)#
                            }
candidates
minWt = 1
candidates
candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                    .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
                # Extract K most similar resources to resources.S2 in S1#
                if(length(resources.S2)) {#
                    for(j in resources.S2) {#
                        candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                        candLink(similar = ., candidates = candidates)#
                    }#
                }#
#
                # Identify K most similar consumers to i in S0#
                consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)#
                if(length(consumers)) {#
                    for(j in consumers) {#
                        target <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j#
#
                        if(length(resource)) { #
                            for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                                similar <- 1#
                                names(similar) <- k#
                                candidates <- candLink(similar = similar, candidates = candidates) #
                            }#
                            for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                                candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                                candLink(similar = ., candidates = candidates)#
                            }#k                           #
                        }#if#
                    }#j#
                }#if
candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                    .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
                # Extract K most similar resources to resources.S2 in S1#
                if(length(resources.S2)) {#
                    for(j in resources.S2) {#
                        candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                        candLink(similar = ., candidates = candidates)#
                    }#
                }#
#
                # Identify K most similar consumers to i in S0#
                consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)#
                if(length(consumers)) {#
                    for(j in consumers) {#
                        target <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j#
#
                        if(length(target)) { #
                            for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                                similar <- 1#
                                names(similar) <- k#
                                candidates <- candLink(similar = similar, candidates = candidates) #
                            }#
                            for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                                candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                                candLink(similar = ., candidates = candidates)#
                            }#k                           #
                        }#if#
                    }#j#
                }#if
candidates
candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                    .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
                # Extract K most similar resources to resources.S2 in S1#
                if(length(resources.S2)) {#
                    for(j in resources.S2) {#
                        candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                        candLink(similar = ., candidates = candidates)#
                    }#
                }#
#
                # Identify K most similar consumers to i in S0#
                consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)#
                if(length(consumers)) {#
                    for(j in consumers) {#
                        target <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j#
#
                        if(length(target)) { #
                            for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                                similar <- 1#
                                names(similar) <- k#
                                candidates <- candLink(similar = similar, candidates = candidates) #
                            }#
                            for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                                candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                                candLink(similar = ., candidates = candidates)#
                            }#k                           #
                        }#if#
                    }#j#
                }#if
candidates
consumers
target
j
consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)
consumers
names(consumers)
candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                    .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
                # Extract K most similar resources to resources.S2 in S1#
                if(length(resources.S2)) {#
                    for(j in resources.S2) {#
                        candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                        candLink(similar = ., candidates = candidates)#
                    }#
                }#
#
                # Identify K most similar consumers to i in S0#
                consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)#
                if(length(consumers)) {#
                    for(j in names(consumers)) {#
                        target <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j#
#
                        if(length(target)) { #
                            for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                                similar <- 1#
                                names(similar) <- k#
                                candidates <- candLink(similar = similar, candidates = candidates) #
                            }#
                            for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                                candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                                candLink(similar = ., candidates = candidates)#
                            }#k                           #
                        }#if#
                    }#j#
                }#if
candidates
consumers
S1
consumers
resources.S2
KNN(taxa = resources.S2, matSim = resSim, K = K, minSim = minSim)
KNN(taxa = resources.S2[1], matSim = resSim, K = K, minSim = minSim)
KNN(taxa = resources.S2[2], matSim = resSim, K = K, minSim = minSim)
KNN(taxa = resources.S2[3], matSim = resSim, K = K, minSim = minSim)
resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                    .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1
resources.S2
KNN(taxa = 'Taxon_4', matSim = resSim, K = K, minSim = minSim)
KNN(taxa = 'Taxon_46', matSim = resSim, K = K, minSim = minSim)
i
KNN <- function(taxa, matSim, K, minSim) {#
    # K nearest neighbout (KNN) selection#
    library(magrittr)#
    # Most similar taxa#
    similar <- matSim[taxa, ] %>%#
                .[!names(.) %in% i] %>% # removing i from most similar resSim#
                .[order(., decreasing = TRUE)] %>%#
                {#
                    if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                        c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                        else .[1:K]#
                } %>%#
                .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
    return(similar)#
}
KNN(taxa = 'Taxon_46', matSim = resSim, K = K, minSim = minSim)
KNN(taxa = 'Taxon_4', matSim = resSim, K = K, minSim = minSim)
KNN <- function(taxa, matSim, K, minSim) {#
    # K nearest neighbout (KNN) selection#
    library(magrittr)#
    # Most similar taxa#
    similar <- matSim[taxa, ] %>%#
                .[!names(.) %in% i] %>% # removing i from most similar resSim#
                .[order(., decreasing = TRUE)] %>%#
                {#
                    if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                        c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                        else .[1:K]#
                } %>%#
                .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
    return(similar)#
}#
#
candLink <- function(similar, candidates) {#
        # Candidate links#
        for(l in names(similar)) { # extracting resource candidates#
            # if((l %in% candidates[, 'target']) == TRUE) { # if candidate is already in candidate list, add resource' with wt to its weight#
            if(l %in% candidates) { # if candidate is already in candidate list, add resource' with wt to its weight#
            # candidates[which(candidates[, 'target'] == l), 'weight'] <- as.numeric(candidates[which(candidates[, 'target'] == l), 'weight']) + as.numeric(similar[l])#
              candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
            } else {#
                  candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it resource' with wt to its weight#
            }#
        }#
    return(candidates)#
}
candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                    .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
                # Extract K most similar resources to resources.S2 in S1#
                if(length(resources.S2)) {#
                    for(j in resources.S2) {#
                        candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                        candLink(similar = ., candidates = candidates)#
                    }#
                }#
#
                # Identify K most similar consumers to i in S0#
                consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)#
                consumers <- #
                if(length(consumers)) {#
                    for(j in names(consumers)) {#
                        target <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j#
#
                        if(length(target)) { #
                            for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                                similar <- 1#
                                names(similar) <- k#
                                candidates <- candLink(similar = similar, candidates = candidates) #
                            }#
                            for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                                candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                                candLink(similar = ., candidates = candidates)#
                            }#k                           #
                        }#if#
                    }#j#
                }#if
candidates
candidates <- .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW
candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW
candidates
predictions
predictions[i, 'resource_predictive'] <- paste(candidates[,'target'], collapse = ' | ')
predictions
i
S2
i = S2[1]
# Empty matrix created to store algorithm predictions#
        predictions <- data.frame(consumer = S1,#
                                    resource_catalogue = character(length(S1)),#
                                    resource_predictive = character(length(S1)),#
                                    row.names = S1,#
                                    stringsAsFactors = FALSE)#
#
        # Catalogue contribution of the algorithm#
        if(predict == 'full algorithm' | predict == 'catalogue') {#
            for(i in S2) {#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) # resources of S2 in S0#
                # Add link with S1 taxa that are considered as linked in S0#
                if(length(resources.S2)) {#
                    predictions[i, 'resource_catalogue'] <- paste(resources.S2[which(resources.S2 %in% S1)], collapse = ' | ')#
                }#
            }#
        }
predictoins
predictions
candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                    .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
                # Extract K most similar resources to resources.S2 in S1#
                if(length(resources.S2)) {#
                    for(j in resources.S2) {#
                        candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                        candLink(similar = ., candidates = candidates)#
                    }#
                }#
#
                # Identify K most similar consumers to i in S0#
                consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)#
                consumers <- #
                if(length(consumers)) {#
                    for(j in names(consumers)) {#
                        target <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j#
#
                        if(length(target)) { #
                            for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                                similar <- 1#
                                names(similar) <- k#
                                candidates <- candLink(similar = similar, candidates = candidates) #
                            }#
                            for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                                candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                                candLink(similar = ., candidates = candidates)#
                            }#k                           #
                        }#if#
                    }#j#
                }#if#
                candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
                predictions[i, 'resource_predictive'] <- paste(candidates[,'target'], collapse = ' | ')
predictions
i
# Predictive contribution of the algorithm, KNN algorithm to infer interactions#
        if(predict == 'full algorithm' | predict == 'predictive') {#
            for(i in S2) {#
                candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                    .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
                # Extract K most similar resources to resources.S2 in S1#
                if(length(resources.S2)) {#
                    for(j in resources.S2) {#
                        candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                        candLink(similar = ., candidates = candidates)#
                    }#
                }#
#
                # Identify K most similar consumers to i in S0#
                consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)#
                consumers <-#
                if(length(consumers)) {#
                    for(j in names(consumers)) {#
                        target <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j#
#
                        if(length(target)) {#
                            for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                                similar <- 1#
                                names(similar) <- k#
                                candidates <- candLink(similar = similar, candidates = candidates)#
                            }#
                            for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                                candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                                candLink(similar = ., candidates = candidates)#
                            }#k#
                        }#if#
                    }#j#
                }#if#
#
                candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
                predictions[i, 'resource_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
            } #i#
        }#if
predictions
iEat <- function(S0, S1, S2 = S1, consSim, resSim = consSim, K = 5, minSim = 0.3, minWt = 1, predict = 'full algorithm') {#
#
    # Parameters:#
        # S0        Matrix, catalogue of empirical data used to infer predictions#
        # S1        Vector, list of taxa forming networking for which topology is predicted#
        # S2        Vector, list of taxa in S1 for which we wish to predict resources#
        #               (if unspecified, S2 == S1 and the whole network is predicted)#
        # consSim   Matrix (numeric), resource similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure consSim[unique(S0,S1), S1]#
        # resSim    Matrix (numeric), resource similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure consSim[unique(S0,S1), S1] (if unspecified,#
        #               resSim == consSim and no similarity distinction between resources and consumers)#
        # K         Integer, how many neighbours for K nearest neighbour evaluation#
        # minSim    Integer, minimum similarity value accepted to consider taxa as similar (implemented to#
        #               avoid unrealistic interactions)#
        # minWt     Integer, minimum weight for candidate resource to become a predicted resource#
        # predict   String, specifies whether the predictions are made from the "full algorithm", the "catalogue"#
        #               or the "predictive" contribution. If unspecified, predict == 'full algorithm'. See#
        #               Beauchesne et al. (2016) for more details. If predict == 'catalogue', the methodology#
        #               corresponds to the approach presented by Gray et al. (2015).#
#
    # Output:#
        # A topology matrix of structure output[S1, S2]#
#
    # TODO: Stops:#
        # if all S1 and S0 not in consSim & resSim rows, stop#
        # if all S2 not in consSim & resSim columns, stop#
        # matrices need to be numeric#
#
    #Embedded functions#
    KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) selection#
        library(magrittr)#
        # Most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar resSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting resource candidates#
                # if((l %in% candidates[, 'target']) == TRUE) { # if candidate is already in candidate list, add resource' with wt to its weight#
                if(l %in% candidates) { # if candidate is already in candidate list, add resource' with wt to its weight#
                # candidates[which(candidates[, 'target'] == l), 'weight'] <- as.numeric(candidates[which(candidates[, 'target'] == l), 'weight']) + as.numeric(similar[l])#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it resource' with wt to its weight#
                }#
            }#
        return(candidates)#
    }#
#
    # Code#
    library(magrittr)#
#
        # Algorithm#
        # Empty matrix created to store algorithm predictions#
        predictions <- data.frame(consumer = S1,#
                                    resource_catalogue = character(length(S1)),#
                                    resource_predictive = character(length(S1)),#
                                    row.names = S1,#
                                    stringsAsFactors = FALSE)#
#
        # Catalogue contribution of the algorithm#
        if(predict == 'full algorithm' | predict == 'catalogue') {#
            for(i in S2) {#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) # resources of S2 in S0#
                # Add link with S1 taxa that are considered as linked in S0#
                if(length(resources.S2)) {#
                    predictions[i, 'resource_catalogue'] <- paste(resources.S2[which(resources.S2 %in% S1)], collapse = ' | ')#
                }#
            }#
        }#
#
        # Predictive contribution of the algorithm, KNN algorithm to infer interactions#
        if(predict == 'full algorithm' | predict == 'predictive') {#
            for(i in S2) {#
                candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                    .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
                # Extract K most similar resources to resources.S2 in S1#
                if(length(resources.S2)) {#
                    for(j in resources.S2) {#
                        candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                        candLink(similar = ., candidates = candidates)#
                    }#
                }#
#
                # Identify K most similar consumers to i in S0#
                consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)#
                consumers <-#
                if(length(consumers)) {#
                    for(j in names(consumers)) {#
                        target <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j#
#
                        if(length(target)) {#
                            for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                                similar <- 1#
                                names(similar) <- k#
                                candidates <- candLink(similar = similar, candidates = candidates)#
                            }#
                            for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                                candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                                candLink(similar = ., candidates = candidates)#
                            }#k#
                        }#if#
                    }#j#
                }#if#
#
                candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
                predictions[i, 'resource_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
            } #i#
        }#if#
}#iEat
iEat(S0 = S0, S1 = S1, S2 = S2, consSim = consSim)
iEat
iEat <- function(S0, S1, S2 = S1, consSim, resSim = consSim, K = 5, minSim = 0.3, minWt = 1, predict = 'full algorithm') {#
#
    # Parameters:#
        # S0        Matrix, catalogue of empirical data used to infer predictions#
        # S1        Vector, list of taxa forming networking for which topology is predicted#
        # S2        Vector, list of taxa in S1 for which we wish to predict resources#
        #               (if unspecified, S2 == S1 and the whole network is predicted)#
        # consSim   Matrix (numeric), resource similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure consSim[unique(S0,S1), S1]#
        # resSim    Matrix (numeric), resource similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure consSim[unique(S0,S1), S1] (if unspecified,#
        #               resSim == consSim and no similarity distinction between resources and consumers)#
        # K         Integer, how many neighbours for K nearest neighbour evaluation#
        # minSim    Integer, minimum similarity value accepted to consider taxa as similar (implemented to#
        #               avoid unrealistic interactions)#
        # minWt     Integer, minimum weight for candidate resource to become a predicted resource#
        # predict   String, specifies whether the predictions are made from the "full algorithm", the "catalogue"#
        #               or the "predictive" contribution. If unspecified, predict == 'full algorithm'. See#
        #               Beauchesne et al. (2016) for more details. If predict == 'catalogue', the methodology#
        #               corresponds to the approach presented by Gray et al. (2015).#
#
    # Output:#
        # A topology matrix of structure output[S1, S2]#
#
    # TODO: Stops:#
        # if all S1 and S0 not in consSim & resSim rows, stop#
        # if all S2 not in consSim & resSim columns, stop#
        # matrices need to be numeric#
#
    #Embedded functions#
    KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) selection#
        library(magrittr)#
        # Most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar resSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting resource candidates#
                # if((l %in% candidates[, 'target']) == TRUE) { # if candidate is already in candidate list, add resource' with wt to its weight#
                if(l %in% candidates) { # if candidate is already in candidate list, add resource' with wt to its weight#
                # candidates[which(candidates[, 'target'] == l), 'weight'] <- as.numeric(candidates[which(candidates[, 'target'] == l), 'weight']) + as.numeric(similar[l])#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it resource' with wt to its weight#
                }#
            }#
        return(candidates)#
    }#
#
    # Code#
    library(magrittr)#
#
        # Algorithm#
        # Empty matrix created to store algorithm predictions#
        predictions <- data.frame(consumer = S1,#
                                    resource_catalogue = character(length(S1)),#
                                    resource_predictive = character(length(S1)),#
                                    row.names = S1,#
                                    stringsAsFactors = FALSE)#
#
        # Catalogue contribution of the algorithm#
        if(predict == 'full algorithm' | predict == 'catalogue') {#
            for(i in S2) {#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) # resources of S2 in S0#
                # Add link with S1 taxa that are considered as linked in S0#
                if(length(resources.S2)) {#
                    predictions[i, 'resource_catalogue'] <- paste(resources.S2[which(resources.S2 %in% S1)], collapse = ' | ')#
                }#
            }#
        }#
#
        # Predictive contribution of the algorithm, KNN algorithm to infer interactions#
        if(predict == 'full algorithm' | predict == 'predictive') {#
            for(i in S2) {#
                candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
                resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                    .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
                # Extract K most similar resources to resources.S2 in S1#
                if(length(resources.S2)) {#
                    for(j in resources.S2) {#
                        candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                        candLink(similar = ., candidates = candidates)#
                    }#
                }#
#
                # Identify K most similar consumers to i in S0#
                consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)#
                consumers <-#
                if(length(consumers)) {#
                    for(j in names(consumers)) {#
                        target <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j#
#
                        if(length(target)) {#
                            for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                                similar <- 1#
                                names(similar) <- k#
                                candidates <- candLink(similar = similar, candidates = candidates)#
                            }#
                            for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                                candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                                candLink(similar = ., candidates = candidates)#
                            }#k#
                        }#if#
                    }#j#
                }#if#
#
                candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
                predictions[i, 'resource_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
            } #i#
        }#if#
    return(predictions)#
}#iEat
iEat
iEat(S0 = S0, S1 = S1, S2 = S2, consSim = consSim)
# Simulated data for testing#
S0 <- paste0('Taxon_',1:100) %>%#
        data.frame(taxon = .,#
            resource = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            consumer = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            row.names = .,#
            stringsAsFactors = FALSE)#
S1 <- as.character(sample(S0[,'taxon'], 10))#
S2 <- S1#
predict = 'full algorithm'#
K = 5#
minSim = 0.3#
minWt = 1#
consSim <- resSim <- matrix(nrow = nrow(S0), ncol = length(S1), data = runif(nrow(S0) * length(S1), min = 0, max = 1), dimnames = list(S0[,'taxon'],S1))
iEat_bin <- function(S0, S1, S2 = S1, consSim, resSim = consSim, K = 5, minSim = 0.3, minWt = 1, predict = 'full algorithm') {#
#
    # Parameters:#
        # S0        Matrix, catalogue of empirical data used to infer predictions#
        # S1        Vector, list of taxa forming networking for which topology is predicted#
        # S2        Vector, list of taxa in S1 for which we wish to predict resources#
        #               (if unspecified, S2 == S1 and the whole network is predicted)#
        # consSim   Matrix (numeric), resource similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure consSim[unique(S0,S1), S1]#
        # resSim    Matrix (numeric), resource similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure consSim[unique(S0,S1), S1] (if unspecified,#
        #               resSim == consSim and no similarity distinction between resources and consumers)#
        # K         Integer, how many neighbours for K nearest neighbour evaluation#
        # minSim    Integer, minimum similarity value accepted to consider taxa as similar (implemented to#
        #               avoid unrealistic interactions)#
        # minWt     Integer, minimum weight for candidate resource to become a predicted resource#
        # predict   String, specifies whether the predictions are made from the "full algorithm", the "catalogue"#
        #               or the "predictive" contribution. If unspecified, predict == 'full algorithm'. See#
        #               Beauchesne et al. (2016) for more details. If predict == 'catalogue', the methodology#
        #               corresponds to the approach presented by Gray et al. (2015).#
#
    # Output:#
        # A topology matrix of structure output[S1, S2]#
#
    # TODO: Stops:#
        # if all S1 and S0 not in consSim & resSim rows, stop#
        # if all S2 not in consSim & resSim columns, stop#
        # matrices need to be numeric#
#
    #Embedded functions#
    KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) selection#
        library(magrittr)#
        # Most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar resSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting resource candidates#
                # if((l %in% candidates[, 'target']) == TRUE) { # if candidate is already in candidate list, add resource' with wt to its weight#
                if(l %in% candidates) { # if candidate is already in candidate list, add resource' with wt to its weight#
                # candidates[which(candidates[, 'target'] == l), 'weight'] <- as.numeric(candidates[which(candidates[, 'target'] == l), 'weight']) + as.numeric(similar[l])#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it resource' with wt to its weight#
                }#
            }#
        return(candidates)#
    }#
#
    # Code#
    library(magrittr)#
#
    # Algorithm#
    # Empty matrix created to store algorithm predictions#
    predictions <- data.frame(consumer = S1,#
                                resource_catalogue = character(length(S1)),#
                                resource_predictive = character(length(S1)),#
                                row.names = S1,#
                                stringsAsFactors = FALSE)#
#
    # Catalogue contribution of the algorithm#
    # if taxa are known to interact in the catalogue, they are assumed to interact in the infered network#
    if(predict == 'full algorithm' | predict == 'catalogue') {#
        for(i in S2) {#
            resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) # resources of S2 in S0#
            # Add link with S1 taxa that are considered as linked in S0#
            if(length(resources.S2)) {#
                predictions[i, 'resource_catalogue'] <- paste(resources.S2[which(resources.S2 %in% S1)], collapse = ' | ')#
            }#
        }#
    }#
#
    # Predictive contribution of the algorithm, KNN algorithm to infer interactions#
    if(predict == 'full algorithm' | predict == 'predictive') {#
        for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
            resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to resources.S2 in S1#
            if(length(resources.S2)) {#
                for(j in resources.S2) {#
                    candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar consumers to i in S0#
            consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)#
            consumers <-#
            if(length(consumers)) {#
                for(j in names(consumers)) {#
                    target <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            predictions[i, 'resource_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i#
    }#if#
    return(predictions)#
}#iEat
rm(list=ls())
iEat_bin <- function(S0, S1, S2 = S1, consSim, resSim = consSim, K = 5, minSim = 0.3, minWt = 1, predict = 'full algorithm') {#
#
    # Parameters:#
        # S0        Matrix, catalogue of empirical data used to infer predictions#
        # S1        Vector, list of taxa forming networking for which topology is predicted#
        # S2        Vector, list of taxa in S1 for which we wish to predict resources#
        #               (if unspecified, S2 == S1 and the whole network is predicted)#
        # consSim   Matrix (numeric), resource similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure consSim[unique(S0,S1), S1]#
        # resSim    Matrix (numeric), resource similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure consSim[unique(S0,S1), S1] (if unspecified,#
        #               resSim == consSim and no similarity distinction between resources and consumers)#
        # K         Integer, how many neighbours for K nearest neighbour evaluation#
        # minSim    Integer, minimum similarity value accepted to consider taxa as similar (implemented to#
        #               avoid unrealistic interactions)#
        # minWt     Integer, minimum weight for candidate resource to become a predicted resource#
        # predict   String, specifies whether the predictions are made from the "full algorithm", the "catalogue"#
        #               or the "predictive" contribution. If unspecified, predict == 'full algorithm'. See#
        #               Beauchesne et al. (2016) for more details. If predict == 'catalogue', the methodology#
        #               corresponds to the approach presented by Gray et al. (2015).#
#
    # Output:#
        # A topology matrix of structure output[S1, S2]#
#
    # TODO: Stops:#
        # if all S1 and S0 not in consSim & resSim rows, stop#
        # if all S2 not in consSim & resSim columns, stop#
        # matrices need to be numeric#
#
    #Embedded functions#
    KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) selection#
        library(magrittr)#
        # Most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar resSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting resource candidates#
                # if((l %in% candidates[, 'target']) == TRUE) { # if candidate is already in candidate list, add resource' with wt to its weight#
                if(l %in% candidates) { # if candidate is already in candidate list, add resource' with wt to its weight#
                # candidates[which(candidates[, 'target'] == l), 'weight'] <- as.numeric(candidates[which(candidates[, 'target'] == l), 'weight']) + as.numeric(similar[l])#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it resource' with wt to its weight#
                }#
            }#
        return(candidates)#
    }#
#
    # Code#
    library(magrittr)#
#
    # Algorithm#
    # Empty matrix created to store algorithm predictions#
    predictions <- data.frame(consumer = S1,#
                                resource_catalogue = character(length(S1)),#
                                resource_predictive = character(length(S1)),#
                                row.names = S1,#
                                stringsAsFactors = FALSE)#
#
    # Catalogue contribution of the algorithm#
    # if taxa are known to interact in the catalogue, they are assumed to interact in the infered network#
    if(predict == 'full algorithm' | predict == 'catalogue') {#
        for(i in S2) {#
            resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) # resources of S2 in S0#
            # Add link with S1 taxa that are considered as linked in S0#
            if(length(resources.S2)) {#
                predictions[i, 'resource_catalogue'] <- paste(resources.S2[which(resources.S2 %in% S1)], collapse = ' | ')#
            }#
        }#
    }#
#
    # Predictive contribution of the algorithm, KNN algorithm to infer interactions#
    if(predict == 'full algorithm' | predict == 'predictive') {#
        for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for resource candidate list for S2[i]#
            resources.S2 <- unlist(strsplit(S0[i, 'resource'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to resources.S2 in S1#
            if(length(resources.S2)) {#
                for(j in resources.S2) {#
                    candidates <- KNN(taxa = j, matSim = resSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar consumers to i in S0#
            consumers <- KNN(taxa = i, matSim = consSim, K = K, minSim = minSim)#
            consumers <-#
            if(length(consumers)) {#
                for(j in names(consumers)) {#
                    target <- unlist(strsplit(S0[j, 'resource'], " \\|\\ ")) # list of resources for consumer j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = resSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            predictions[i, 'resource_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i#
    }#if#
    return(predictions)#
}#iEat#
#
# Simulated data for testing#
S0 <- paste0('Taxon_',1:100) %>%#
        data.frame(taxon = .,#
            resource = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            consumer = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            row.names = .,#
            stringsAsFactors = FALSE)#
S1 <- as.character(sample(S0[,'taxon'], 10))#
S2 <- S1#
predict = 'full algorithm'#
K = 5#
minSim = 0.3#
minWt = 1#
consSim <- resSim <- matrix(nrow = nrow(S0), ncol = length(S1), data = runif(nrow(S0) * length(S1), min = 0, max = 1), dimnames = list(S0[,'taxon'],S1))
ls()
iEat_bin(S0,S1,S2,consSim)
iEat_bin <- function(S0, S1, S2 = S1, sourceSim, targetSim = sourceSim, K = 5, minSim = 0.3, minWt = 1, predict = 'full algorithm') {#
#
    # Parameters:#
        # S0        Matrix, catalogue of empirical data used to infer predictions#
        # S1        Vector, list of taxa forming networking for which topology is predicted#
        # S2        Vector, list of taxa in S1 for which we wish to predict resources#
        #               (if unspecified, S2 == S1 and the whole network is predicted)#
        # sourceSim   Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure sourceSim[unique(S0,S1), S1]#
        # targetSim    Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure sourceSim[unique(S0,S1), S1] (if unspecified,#
        #               targetSim == sourceSim and no similarity distinction between resources and consumers)#
        # K         Integer, how many neighbours for K nearest neighbour evaluation#
        # minSim    Integer, minimum similarity value accepted to consider taxa as similar (implemented to#
        #               avoid unrealistic interactions)#
        # minWt     Integer, minimum weight for candidate source to become a predicted source#
        # predict   String, specifies whether the predictions are made from the "full algorithm", the "catalogue"#
        #               or the "predictive" contribution. If unspecified, predict == 'full algorithm'. See#
        #               Beauchesne et al. (2016) for more details. If predict == 'catalogue', the methodology#
        #               corresponds to the approach presented by Gray et al. (2015).#
#
    # Output:#
        # A topology matrix of structure output[S1, S2]#
#
    # TODO: Stops:#
        # if all S1 and S0 not in sourceSim & targetSim rows, stop#
        # if all S2 not in sourceSim & targetSim columns, stop#
        # matrices need to be numeric#
#
    #Embedded functions#
    KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) selection#
        library(magrittr)#
        # Most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar targetSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting source candidates#
                # if((l %in% candidates[, 'target']) == TRUE) { # if candidate is already in candidate list, add source' with wt to its weight#
                if(l %in% candidates) { # if candidate is already in candidate list, add source' with wt to its weight#
                # candidates[which(candidates[, 'target'] == l), 'weight'] <- as.numeric(candidates[which(candidates[, 'target'] == l), 'weight']) + as.numeric(similar[l])#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it source' with wt to its weight#
                }#
            }#
        return(candidates)#
    }#
#
    # Code#
    library(magrittr)#
#
    # Algorithm#
    # Empty matrix created to store algorithm predictions#
    predictions <- data.frame(source = S1,#
                                target_catalogue = character(length(S1)),#
                                target_predictive = character(length(S1)),#
                                row.names = S1,#
                                stringsAsFactors = FALSE)#
#
    # Catalogue contribution of the algorithm#
    # if taxa are known to interact in the catalogue, they are assumed to interact in the infered network#
    if(predict == 'full algorithm' | predict == 'catalogue') {#
        for(i in S2) {#
            target.S2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) # resources of S2 in S0#
            # Add link with S1 taxa that are considered as linked in S0#
            if(length(targetS2)) {#
                predictions[i, 'target_catalogue'] <- paste(targetS2[which(targetS2 %in% S1)], collapse = ' | ')#
            }#
        }#
    }#
#
    # Predictive contribution of the algorithm, KNN algorithm to infer interactions#
    if(predict == 'full algorithm' | predict == 'predictive') {#
        for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            predictions[i, 'target_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i#
    }#if#
    return(predictions)#
}#iEat#
#
# Simulated data for testing#
S0 <- paste0('Taxon_',1:100) %>%#
        data.frame(taxon = .,#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            row.names = .,#
            stringsAsFactors = FALSE)#
S1 <- as.character(sample(S0[,'taxon'], 10))#
S2 <- S1#
predict = 'full algorithm'#
K = 5#
minSim = 0.3#
minWt = 1#
sourceSim <- targetSim <- matrix(nrow = nrow(S0), ncol = length(S1), data = runif(nrow(S0) * length(S1), min = 0, max = 1), dimnames = list(S0[,'taxon'],S1))
ls()
rm(list=ls())
iEat_bin <- function(S0, S1, S2 = S1, sourceSim, targetSim = sourceSim, K = 5, minSim = 0.3, minWt = 1, predict = 'full algorithm') {#
#
    # Parameters:#
        # S0        Matrix, catalogue of empirical data used to infer predictions#
        # S1        Vector, list of taxa forming networking for which topology is predicted#
        # S2        Vector, list of taxa in S1 for which we wish to predict resources#
        #               (if unspecified, S2 == S1 and the whole network is predicted)#
        # sourceSim   Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure sourceSim[unique(S0,S1), S1]#
        # targetSim    Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure sourceSim[unique(S0,S1), S1] (if unspecified,#
        #               targetSim == sourceSim and no similarity distinction between resources and consumers)#
        # K         Integer, how many neighbours for K nearest neighbour evaluation#
        # minSim    Integer, minimum similarity value accepted to consider taxa as similar (implemented to#
        #               avoid unrealistic interactions)#
        # minWt     Integer, minimum weight for candidate source to become a predicted source#
        # predict   String, specifies whether the predictions are made from the "full algorithm", the "catalogue"#
        #               or the "predictive" contribution. If unspecified, predict == 'full algorithm'. See#
        #               Beauchesne et al. (2016) for more details. If predict == 'catalogue', the methodology#
        #               corresponds to the approach presented by Gray et al. (2015).#
#
    # Output:#
        # A topology matrix of structure output[S1, S2]#
#
    # TODO: Stops:#
        # if all S1 and S0 not in sourceSim & targetSim rows, stop#
        # if all S2 not in sourceSim & targetSim columns, stop#
        # matrices need to be numeric#
#
    #Embedded functions#
    KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) selection#
        library(magrittr)#
        # Most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar targetSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting source candidates#
                # if((l %in% candidates[, 'target']) == TRUE) { # if candidate is already in candidate list, add source' with wt to its weight#
                if(l %in% candidates) { # if candidate is already in candidate list, add source' with wt to its weight#
                # candidates[which(candidates[, 'target'] == l), 'weight'] <- as.numeric(candidates[which(candidates[, 'target'] == l), 'weight']) + as.numeric(similar[l])#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it source' with wt to its weight#
                }#
            }#
        return(candidates)#
    }#
#
    # Code#
    library(magrittr)#
#
    # Algorithm#
    # Empty matrix created to store algorithm predictions#
    predictions <- data.frame(source = S1,#
                                target_catalogue = character(length(S1)),#
                                target_predictive = character(length(S1)),#
                                row.names = S1,#
                                stringsAsFactors = FALSE)#
#
    # Catalogue contribution of the algorithm#
    # if taxa are known to interact in the catalogue, they are assumed to interact in the infered network#
    if(predict == 'full algorithm' | predict == 'catalogue') {#
        for(i in S2) {#
            target.S2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) # resources of S2 in S0#
            # Add link with S1 taxa that are considered as linked in S0#
            if(length(targetS2)) {#
                predictions[i, 'target_catalogue'] <- paste(targetS2[which(targetS2 %in% S1)], collapse = ' | ')#
            }#
        }#
    }#
#
    # Predictive contribution of the algorithm, KNN algorithm to infer interactions#
    if(predict == 'full algorithm' | predict == 'predictive') {#
        for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            predictions[i, 'target_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i#
    }#if#
    return(predictions)#
}#iEat#
#
# Simulated data for testing#
S0 <- paste0('Taxon_',1:100) %>%#
        data.frame(taxon = .,#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            row.names = .,#
            stringsAsFactors = FALSE)#
S1 <- as.character(sample(S0[,'taxon'], 10))#
S2 <- S1#
predict = 'full algorithm'#
K = 5#
minSim = 0.3#
minWt = 1#
sourceSim <- targetSim <- matrix(nrow = nrow(S0), ncol = length(S1), data = runif(nrow(S0) * length(S1), min = 0, max = 1), dimnames = list(S0[,'taxon'],S1))
iEat_bin(S0,S1,S2,sourceSim)
rm(list=ls())
iEat_bin <- function(S0, S1, S2 = S1, sourceSim, targetSim = sourceSim, K = 5, minSim = 0.3, minWt = 1, predict = 'full algorithm') {#
#
    # Parameters:#
        # S0        Matrix, catalogue of empirical data used to infer predictions#
        # S1        Vector, list of taxa forming networking for which topology is predicted#
        # S2        Vector, list of taxa in S1 for which we wish to predict resources#
        #               (if unspecified, S2 == S1 and the whole network is predicted)#
        # sourceSim   Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure sourceSim[unique(S0,S1), S1]#
        # targetSim    Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure sourceSim[unique(S0,S1), S1] (if unspecified,#
        #               targetSim == sourceSim and no similarity distinction between resources and consumers)#
        # K         Integer, how many neighbours for K nearest neighbour evaluation#
        # minSim    Integer, minimum similarity value accepted to consider taxa as similar (implemented to#
        #               avoid unrealistic interactions)#
        # minWt     Integer, minimum weight for candidate source to become a predicted source#
        # predict   String, specifies whether the predictions are made from the "full algorithm", the "catalogue"#
        #               or the "predictive" contribution. If unspecified, predict == 'full algorithm'. See#
        #               Beauchesne et al. (2016) for more details. If predict == 'catalogue', the methodology#
        #               corresponds to the approach presented by Gray et al. (2015).#
#
    # Output:#
        # A topology matrix of structure output[S1, S2]#
#
    # TODO: Stops:#
        # if all S1 and S0 not in sourceSim & targetSim rows, stop#
        # if all S2 not in sourceSim & targetSim columns, stop#
        # matrices need to be numeric#
#
    #Embedded functions#
    KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) selection#
        library(magrittr)#
        # Most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar targetSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting source candidates#
                # if((l %in% candidates[, 'target']) == TRUE) { # if candidate is already in candidate list, add source' with wt to its weight#
                if(l %in% candidates) { # if candidate is already in candidate list, add source' with wt to its weight#
                # candidates[which(candidates[, 'target'] == l), 'weight'] <- as.numeric(candidates[which(candidates[, 'target'] == l), 'weight']) + as.numeric(similar[l])#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it source' with wt to its weight#
                }#
            }#
        return(candidates)#
    }#
#
    # Code#
    library(magrittr)#
#
    # Algorithm#
    # Empty matrix created to store algorithm predictions#
    predictions <- data.frame(source = S1,#
                                target_catalogue = character(length(S1)),#
                                target_predictive = character(length(S1)),#
                                row.names = S1,#
                                stringsAsFactors = FALSE)#
#
    # Catalogue contribution of the algorithm#
    # if taxa are known to interact in the catalogue, they are assumed to interact in the infered network#
    if(predict == 'full algorithm' | predict == 'catalogue') {#
        for(i in S2) {#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) # resources of S2 in S0#
            # Add link with S1 taxa that are considered as linked in S0#
            if(length(targetS2)) {#
                predictions[i, 'target_catalogue'] <- paste(targetS2[which(targetS2 %in% S1)], collapse = ' | ')#
            }#
        }#
    }#
#
    # Predictive contribution of the algorithm, KNN algorithm to infer interactions#
    if(predict == 'full algorithm' | predict == 'predictive') {#
        for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            predictions[i, 'target_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i#
    }#if#
    return(predictions)#
}#iEat#
#
# Simulated data for testing#
S0 <- paste0('Taxon_',1:100) %>%#
        data.frame(taxon = .,#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            row.names = .,#
            stringsAsFactors = FALSE)#
S1 <- as.character(sample(S0[,'taxon'], 10))#
S2 <- S1#
predict = 'full algorithm'#
K = 5#
minSim = 0.3#
minWt = 1#
sourceSim <- targetSim <- matrix(nrow = nrow(S0), ncol = length(S1), data = runif(nrow(S0) * length(S1), min = 0, max = 1), dimnames = list(S0[,'taxon'],S1))
iEat_bin(S0,S1,S2,sourceSim)
iEat_bin <- function(S0, S1, S2 = S1, sourceSim, targetSim = sourceSim, K = 5, minSim = 0.3, minWt = 1, predict = 'full algorithm') {#
#
    # Parameters:#
        # S0        Matrix, catalogue of empirical data used to infer predictions#
        # S1        Vector, list of taxa forming networking for which topology is predicted#
        # S2        Vector, list of taxa in S1 for which we wish to predict resources#
        #               (if unspecified, S2 == S1 and the whole network is predicted)#
        # sourceSim   Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure sourceSim[unique(S0,S1), S1]#
        # targetSim    Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa,#
        #               structure sourceSim[unique(S0,S1), S1] (if unspecified,#
        #               targetSim == sourceSim and no similarity distinction between resources and consumers)#
        # K         Integer, how many neighbours for K nearest neighbour evaluation#
        # minSim    Integer, minimum similarity value accepted to consider taxa as similar (implemented to#
        #               avoid unrealistic interactions)#
        # minWt     Integer, minimum weight for candidate source to become a predicted source#
        # predict   String, specifies whether the predictions are made from the "full algorithm", the "catalogue"#
        #               or the "predictive" contribution. If unspecified, predict == 'full algorithm'. See#
        #               Beauchesne et al. (2016) for more details. If predict == 'catalogue', the methodology#
        #               corresponds to the approach presented by Gray et al. (2015).#
#
    # Output:#
        # A topology matrix of structure output[S1, S2]#
#
    # TODO: Stops:#
        # if all S1 and S0 not in sourceSim & targetSim rows, stop#
        # if all S2 not in sourceSim & targetSim columns, stop#
        # matrices need to be numeric#
#
    #Embedded functions#
    KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) selection#
        library(magrittr)#
        # Most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar targetSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting source candidates#
                # if((l %in% candidates[, 'target']) == TRUE) { # if candidate is already in candidate list, add source' with wt to its weight#
                if(l %in% candidates) { # if candidate is already in candidate list, add source' with wt to its weight#
                # candidates[which(candidates[, 'target'] == l), 'weight'] <- as.numeric(candidates[which(candidates[, 'target'] == l), 'weight']) + as.numeric(similar[l])#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it source' with wt to its weight#
                }#
            }#
        return(candidates)#
    }#
#
    # Code#
    library(magrittr)#
#
    # Algorithm#
    # Empty matrix created to store algorithm predictions#
    predictions <- data.frame(source = S1,#
                                target_catalogue = character(length(S1)),#
                                target_predictive = character(length(S1)),#
                                row.names = S1,#
                                stringsAsFactors = FALSE)#
#
    # Catalogue contribution of the algorithm#
    # if taxa are known to interact in the catalogue, they are assumed to interact in the infered network#
    if(predict == 'full algorithm' | predict == 'catalogue') {#
        for(i in S2) {#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) # resources of S2 in S0#
            # Add link with S1 taxa that are considered as linked in S0#
            if(length(targetS2)) {#
                predictions[i, 'target_catalogue'] <- paste(targetS2[which(targetS2 %in% S1)], collapse = ' | ')#
            }#
        }#
    }#
#
    # Predictive contribution of the algorithm, KNN algorithm to infer interactions#
    if(predict == 'full algorithm' | predict == 'predictive') {#
        for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            predictions[i, 'target_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i#
    }#if#
    return(predictions)#
}#iEat#
#
# Simulated data for testing#
S0 <- paste0('Taxon_',1:100) %>%#
        data.frame(taxon = .,#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            row.names = .,#
            stringsAsFactors = FALSE)#
S1 <- as.character(sample(S0[,'taxon'], 10))#
S2 <- S1#
predict = 'full algorithm'#
K = 5#
minSim = 0.3#
minWt = 1#
sourceSim <- targetSim <- matrix(nrow = nrow(S0), ncol = length(S1), data = runif(nrow(S0) * length(S1), min = 0, max = 1), dimnames = list(S0[,'taxon'],S1))
iEat_bin(S0,S1,S2,sourceSim)
rm(list=ls())
#' @name iEat_bin#
#' @title Instance-based machine learning method to predict biotic interactions#
#' @param S0 Matrix, catalogue of empirical data used to infer predictions#
#' @param S1 Vector of taxa forming networking for which topology is predicted#
#' @param S2 Vector of taxa in S1 for which we wish to predict resources (if unspecified, S2 == S1 and the whole network is predicted)#
#' @param sourceSim Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa, structure sourceSim[unique(S0,S1), S1]#
#' @param targetSim Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa, structure sourceSim[unique(S0,S1), S1] (if unspecified, targetSim == sourceSim and no similarity distinction between resources and consumers)#
#' @param K Integer, how many neighbours for K nearest neighbour evaluation#
#' @param minSim Integer, minimum similarity value accepted to consider taxa as similar (implemented to avoid unrealistic interactions)#
#' @param minWt Integer, minimum weight for candidate source to become a predicted source#
#' @param predict String, specifies whether the predictions are made from the "full algorithm", the "catalogue" or the "predictive" contribution. If unspecified, predict == 'full algorithm'. See Beauchesne et al. (2016) for more details. If predict == 'catalogue', the methodology corresponds to the approach presented by Gray et al. (2015).#
#' @return#
#' A dataframe with source taxa for which target predictions are made, target infered from catalogue data (empirical) and target infered from KNN algorithm#
#' @author#
#' David Beauchesne#
#' @importFrom magrittr %>%#
#' @rdname iEat_bin#
#' @export#
# TODO: Stops:#
    # if all S1 and S0 not in sourceSim & targetSim rows, stop#
    # if all S2 not in sourceSim & targetSim columns, stop#
    # matrices need to be numeric#
#
iEat_bin <- function(S0, S1, S2 = S1, sourceSim, targetSim = sourceSim, K = 5, minSim = 0.3, minWt = 1, predict = 'full algorithm') {#
    # Empty matrix created to store algorithm predictions#
    predictions <- data.frame(source = S1,#
                                target_catalogue = character(length(S1)),#
                                target_predictive = character(length(S1)),#
                                row.names = S1,#
                                stringsAsFactors = FALSE)#
#
    # Catalogue contribution of the algorithm#
    # if taxa are known to interact in the catalogue, they are assumed to interact in the infered network#
    if(predict == 'full algorithm' | predict == 'catalogue') {#
        for(i in S2) {#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) # resources of S2 in S0#
            # Add link with S1 taxa that are considered as linked in S0#
            if(length(targetS2)) {#
                predictions[i, 'target_catalogue'] <- paste(targetS2[which(targetS2 %in% S1)], collapse = ' | ')#
            }#
        }#
    }#
#
    # Predictive contribution of the algorithm, KNN algorithm to infer interactions#
    if(predict == 'full algorithm' | predict == 'predictive') {#
        for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            predictions[i, 'target_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i#
    }#if#
    return(predictions)#
#
    #Embedded functions#
    KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) selection#
        # Most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar targetSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting source candidates#
                if(l %in% candidates) { # if candidate is already in candidate list, add source' with wt to its weight#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it source' with wt to its weight#
                }#
            }#
        return(candidates)#
    }#
}#iEat
iEat_bin(S0,S1,S2,sourceSim)
# Simulated data for testing#
S0 <- paste0('Taxon_',1:100) %>%#
        data.frame(taxon = .,#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            row.names = .,#
            stringsAsFactors = FALSE)#
S1 <- as.character(sample(S0[,'taxon'], 10))#
S2 <- S1#
predict = 'full algorithm'#
K = 5#
minSim = 0.3#
minWt = 1#
sourceSim <- targetSim <- matrix(nrow = nrow(S0), ncol = length(S1), data = runif(nrow(S0) * length(S1), min = 0, max = 1), dimnames = list(S0[,'taxon'],S1))
iEat_bin(S0,S1,S2,sourceSim)
#' @name iEat_bin#
#' @title Instance-based machine learning method to predict biotic interactions#
#' @param S0 Matrix, catalogue of empirical data used to infer predictions#
#' @param S1 Vector of taxa forming networking for which topology is predicted#
#' @param S2 Vector of taxa in S1 for which we wish to predict resources (if unspecified, S2 == S1 and the whole network is predicted)#
#' @param sourceSim Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa, structure sourceSim[unique(S0,S1), S1]#
#' @param targetSim Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa, structure sourceSim[unique(S0,S1), S1] (if unspecified, targetSim == sourceSim and no similarity distinction between resources and consumers)#
#' @param K Integer, how many neighbours for K nearest neighbour evaluation#
#' @param minSim Integer, minimum similarity value accepted to consider taxa as similar (implemented to avoid unrealistic interactions)#
#' @param minWt Integer, minimum weight for candidate source to become a predicted source#
#' @param predict String, specifies whether the predictions are made from the "full algorithm", the "catalogue" or the "predictive" contribution. If unspecified, predict == 'full algorithm'. See Beauchesne et al. (2016) for more details. If predict == 'catalogue', the methodology corresponds to the approach presented by Gray et al. (2015).#
#' @return#
#' A dataframe with source taxa for which target predictions are made, target infered from catalogue data (empirical) and target infered from KNN algorithm#
#' @author#
#' David Beauchesne#
#' @importFrom magrittr %>%#
#' @rdname iEat_bin#
#' @export#
# TODO: Stops:#
    # if all S1 and S0 not in sourceSim & targetSim rows, stop#
    # if all S2 not in sourceSim & targetSim columns, stop#
    # matrices need to be numeric#
#
iEat_bin <- function(S0, S1, S2 = S1, sourceSim, targetSim = sourceSim, K = 5, minSim = 0.3, minWt = 1, predict = 'full algorithm') {#
    # Empty matrix created to store algorithm predictions#
    predictions <- data.frame(source = S1,#
                                target_catalogue = character(length(S1)),#
                                target_predictive = character(length(S1)),#
                                row.names = S1,#
                                stringsAsFactors = FALSE)#
#
    # Catalogue contribution of the algorithm#
    # if taxa are known to interact in the catalogue, they are assumed to interact in the infered network#
    if(predict == 'full algorithm' | predict == 'catalogue') {#
        for(i in S2) {#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) # resources of S2 in S0#
            # Add link with S1 taxa that are considered as linked in S0#
            if(length(targetS2)) {#
                predictions[i, 'target_catalogue'] <- paste(targetS2[which(targetS2 %in% S1)], collapse = ' | ')#
            }#
        }#
    }#
#
    # Predictive contribution of the algorithm, KNN algorithm to infer interactions#
    if(predict == 'full algorithm' | predict == 'predictive') {#
        for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            predictions[i, 'target_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i#
    }#if#
    return(predictions)#
#
    #Embedded functions#
    KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) selection#
        # Most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar targetSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting source candidates#
                if(l %in% candidates) { # if candidate is already in candidate list, add source' with wt to its weight#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it source' with wt to its weight#
                }#
            }#
        return(candidates)#
    }#
}#iEat
iEat_bin(S0,S1,S2,sourceSim)
#' @name iEat_bin#
#' @title Instance-based machine learning method to predict biotic interactions#
#' @param S0 Matrix, catalogue of empirical data used to infer predictions#
#' @param S1 Vector of taxa forming networking for which topology is predicted#
#' @param S2 Vector of taxa in S1 for which we wish to predict resources (if unspecified, S2 == S1 and the whole network is predicted)#
#' @param sourceSim Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa, structure sourceSim[unique(S0,S1), S1]#
#' @param targetSim Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa, structure sourceSim[unique(S0,S1), S1] (if unspecified, targetSim == sourceSim and no similarity distinction between resources and consumers)#
#' @param K Integer, how many neighbours for K nearest neighbour evaluation#
#' @param minSim Integer, minimum similarity value accepted to consider taxa as similar (implemented to avoid unrealistic interactions)#
#' @param minWt Integer, minimum weight for candidate source to become a predicted source#
#' @param predict String, specifies whether the predictions are made from the "full algorithm", the "catalogue" or the "predictive" contribution. If unspecified, predict == 'full algorithm'. See Beauchesne et al. (2016) for more details. If predict == 'catalogue', the methodology corresponds to the approach presented by Gray et al. (2015).#
#' @return#
#' A dataframe with source taxa for which target predictions are made, target infered from catalogue data (empirical) and target infered from KNN algorithm#
#' @author#
#' David Beauchesne#
#' @importFrom magrittr %>%#
#' @rdname iEat_bin#
#' @export#
# TODO: Stops:#
    # if all S1 and S0 not in sourceSim & targetSim rows, stop#
    # if all S2 not in sourceSim & targetSim columns, stop#
    # matrices need to be numeric#
#
iEat_bin <- function(S0, S1, S2 = S1, sourceSim, targetSim = sourceSim, K = 5, minSim = 0.3, minWt = 1, predict = 'full algorithm') {#
    #Embedded functions#
    KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) selection#
        # Most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar targetSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting source candidates#
                if(l %in% candidates) { # if candidate is already in candidate list, add source' with wt to its weight#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it source' with wt to its weight#
                }#
            }#
        return(candidates)#
    }#
#
    # Algorithm#
    # Empty matrix created to store algorithm predictions#
    predictions <- data.frame(source = S1,#
                                target_catalogue = character(length(S1)),#
                                target_predictive = character(length(S1)),#
                                row.names = S1,#
                                stringsAsFactors = FALSE)#
#
    # Catalogue contribution of the algorithm#
    # if taxa are known to interact in the catalogue, they are assumed to interact in the infered network#
    if(predict == 'full algorithm' | predict == 'catalogue') {#
        for(i in S2) {#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) # resources of S2 in S0#
            # Add link with S1 taxa that are considered as linked in S0#
            if(length(targetS2)) {#
                predictions[i, 'target_catalogue'] <- paste(targetS2[which(targetS2 %in% S1)], collapse = ' | ')#
            }#
        }#
    }#
#
    # Predictive contribution of the algorithm, KNN algorithm to infer interactions#
    if(predict == 'full algorithm' | predict == 'predictive') {#
        for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            predictions[i, 'target_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i#
    }#if#
    return(predictions)#
}#iEat
iEat_bin(S0,S1,S2,sourceSim)
# Simulated data for testing#
ncat <- 100#
npred <- 100#
S0 <- paste0('Taxon_',1:ncat) %>%#
        data.frame(taxon = .,#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            row.names = .,#
            stringsAsFactors = FALSE)#
S1 <- as.character(sample(S0[,'taxon'], npred))#
S2 <- S1#
predict = 'full algorithm'#
K = 5#
minSim = 0.3#
minWt = 1#
sourceSim <- targetSim <- matrix(nrow = nrow(S0), ncol = length(S1), data = runif(nrow(S0) * length(S1), min = 0, max = 1), dimnames = list(S0[,'taxon'],S1))
S0
# Simulated data for testing#
ncat <- 100#
npred <- 100#
S0 <- paste0('Taxon_',1:ncat) %>%#
        data.frame(taxon = .,#
            target = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            row.names = .,#
            stringsAsFactors = FALSE)#
S1 <- as.character(sample(S0[,'taxon'], npred))#
S2 <- S1#
predict = 'full algorithm'#
K = 5#
minSim = 0.3#
minWt = 1#
sourceSim <- targetSim <- matrix(nrow = nrow(S0), ncol = length(S1), data = runif(nrow(S0) * length(S1), min = 0, max = 1), dimnames = list(S0[,'taxon'],S1))
head(S0)
iEat_bin(S0,S1,S2,sourceSim)
nrow(iEat_bin(S0,S1,S2,sourceSim))
S1
S0
# Simulated data for testing#
ncat <- 10000#
npred <- 100#
S0 <- paste0('Taxon_',1:ncat) %>%#
        data.frame(taxon = .,#
            target = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            row.names = .,#
            stringsAsFactors = FALSE)#
S1 <- as.character(sample(S0[,'taxon'], npred))#
S2 <- S1#
predict = 'full algorithm'#
K = 5#
minSim = 0.3#
minWt = 1#
sourceSim <- targetSim <- matrix(nrow = nrow(S0), ncol = length(S1), data = runif(nrow(S0) * length(S1), min = 0, max = 1), dimnames = list(S0[,'taxon'],S1))
dim(S0)
system.time(iEat_bin(S0,S1,S2,sourceSim)))
system.time(iEat_bin(S0,S1,S2,sourceSim))
ncat <- 100000#
npred <- 1360#
S0 <- paste0('Taxon_',1:ncat) %>%#
        data.frame(taxon = .,#
            target = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            source = replicate(n = length(.), expr = paste(sample(., round(runif(1,1,8))), collapse = ' | ')),#
            row.names = .,#
            stringsAsFactors = FALSE)#
S1 <- as.character(sample(S0[,'taxon'], npred))#
S2 <- S1#
predict = 'full algorithm'#
K = 5#
minSim = 0.3#
minWt = 1#
sourceSim <- targetSim <- matrix(nrow = nrow(S0), ncol = length(S1), data = runif(nrow(S0) * length(S1), min = 0, max = 1), dimnames = list(S0[,'taxon'],S1))
system.time(iEat_bin(S0,S1,S2,sourceSim))
i
ls()
for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            predictions[i, 'target_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i
KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) majority vote selection to identify most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar targetSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting source candidates#
                if(l %in% candidates) { # if candidate is already in candidate list, add source' with wt to its weight#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it source' with wt to its weight#
                }#
            }#
        return(candidates)#
    }
for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            predictions[i, 'target_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i
predictions <- data.frame(source = S1,#
                                target_catalogue = character(length(S1)),#
                                target_predictive = character(length(S1)),#
                                row.names = S1,#
                                stringsAsFactors = FALSE)
for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            predictions[i, 'target_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i
i
candidates
S0[i, ]
j
candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }
candidates
i
j
k
l
# Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if
candidates
candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW
candidates
predictions[i, 'target_predictive'] <- paste(candidates[,'target'], collapse = ' | ')
predictions
candidates
as.matric(candidates)
x <- as.matrix(candidates)
x[,target]
x[,'target']
x['target']
x
candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ]
candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if
candidates %>% .[which(.[, 'weight'] >= minWt), ]
candidates %>% .[which(.[, 'weight'] >= minWt), 'target']
candidates %>% .[which(.[, 'weight'] >= 0.5), 'target']
candidates %>% .[which(.[, 'weight'] >= 0.5), 'target'] %>% paste(., collapse = ' | ')
#' @name iEat_bin#
#' @title Instance-based machine learning method to predict biotic interactions#
#' @param S0 Matrix, catalogue of empirical data used to infer predictions#
#' @param S1 Vector of taxa forming networking for which topology is predicted#
#' @param S2 Vector of taxa in S1 for which we wish to predict resources (if unspecified, S2 == S1 and the whole network is predicted)#
#' @param sourceSim Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa, structure sourceSim[unique(S0,S1), S1]#
#' @param targetSim Matrix (numeric), source similarity matrix between S1 taxa and the union of S0 and S1 taxa, structure sourceSim[unique(S0,S1), S1] (if unspecified, targetSim == sourceSim and no similarity distinction between resources and consumers)#
#' @param K Integer, how many neighbours for K nearest neighbour evaluation#
#' @param minSim Integer, minimum similarity value accepted to consider taxa as similar (implemented to avoid unrealistic interactions)#
#' @param minWt Integer, minimum weight for candidate source to become a predicted source#
#' @param predict String, specifies whether the predictions are made from the "full algorithm", the "catalogue" or the "predictive" contribution. If unspecified, predict == 'full algorithm'. See Beauchesne et al. (2016) for more details. If predict == 'catalogue', the methodology corresponds to the approach presented by Gray et al. (2015).#
#' @return#
#' A dataframe with source taxa for which target predictions are made, target infered from catalogue data (empirical) and target infered from KNN algorithm#
#' @author#
#' David Beauchesne#
#' @importFrom magrittr %>%#
#' @rdname iEat_bin#
#' @export#
# TODO: Stops:#
    # if all S1 and S0 not in sourceSim & targetSim rows, stop#
    # if all S2 not in sourceSim & targetSim columns, stop#
    # matrices need to be numeric#
#
iEat_bin <- function(S0, S1, S2 = S1, sourceSim, targetSim = sourceSim, K = 5, minSim = 0.3, minWt = 1, predict = 'full algorithm') {#
    #Embedded functions#
    KNN <- function(taxa, matSim, K, minSim) {#
        # K nearest neighbout (KNN) majority vote selection to identify most similar taxa#
        similar <- matSim[taxa, ] %>%#
                    .[!names(.) %in% i] %>% # removing i from most similar targetSim#
                    .[order(., decreasing = TRUE)] %>%#
                    {#
                        if(.[K+1] == .[K]) # if K + 1 == K, randomly sample a most similar taxa and pick K most similar taxa#
                            c(.[which(. > .[K])], .[sample(which(. == .[K]))])[1:K]#
                            else .[1:K]#
                    } %>%#
                    .[!. == 0 & . > minSim] # remove all similarities == 0 and similarities below minSim#
        return(similar)#
    }#
#
    candLink <- function(similar, candidates) {#
            # Candidate links#
            for(l in names(similar)) { # extracting source candidates#
                if(l %in% candidates) { # if candidate is already in candidate list, add source' with wt to its weight#
                  candidates[which(candidates %in% l), 'weight'] <- as.numeric(candidates[which(candidates %in% l), 'weight']) + similar[l]#
                } else {#
                      candidates <- rbind(candidates, c(l,similar[l])) # if candidate is not in the list, add it source' with wt to its weight#
                }#
            }#
        return(candidates)#
    }#
#
    # Algorithm#
    # Empty matrix created to store algorithm predictions#
    predictions <- data.frame(source = S1,#
                                target_catalogue = character(length(S1)),#
                                target_predictive = character(length(S1)),#
                                row.names = S1,#
                                stringsAsFactors = FALSE)#
#
    # Catalogue contribution of the algorithm#
    # if taxa are known to interact in the catalogue, they are assumed to interact in the infered network#
    if(predict == 'full algorithm' | predict == 'catalogue') {#
        for(i in S2) {#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) # resources of S2 in S0#
            # Add link with S1 taxa that are considered as linked in S0#
            if(length(targetS2)) {#
                predictions[i, 'target_catalogue'] <- paste(targetS2[which(targetS2 %in% S1)], collapse = ' | ')#
            }#
        }#
    }#
#
    # Predictive contribution of the algorithm, KNN algorithm to infer interactions#
    if(predict == 'full algorithm' | predict == 'predictive') {#
        for(i in S2) {#
            candidates <- matrix(nrow = 0, ncol = 2, dimnames = list(c(), c('target','weight'))) # Empty matrix for source candidate list for S2[i]#
            targetS2 <- unlist(strsplit(S0[i, 'source'], " \\|\\ ")) %>%#
                                .[which(!. %in% S1)] # resources of S2 in S0 that are not in S1#
#
            # Extract K most similar resources to targetS2 in S1#
            if(length(targetS2)) {#
                for(j in targetS2) {#
                    candidates <- KNN(taxa = j, matSim = targetSim, K = K, minSim = minSim) %>%#
                                    candLink(similar = ., candidates = candidates)#
                }#
            }#
#
            # Identify K most similar source to i in S0#
            simSource <- KNN(taxa = i, matSim = sourceSim, K = K, minSim = minSim)#
            if(length(simSource)) {#
                for(j in names(simSource)) {#
                    target <- unlist(strsplit(S0[j, 'source'], " \\|\\ ")) # list of resources for source j#
#
                    if(length(target)) {#
                        for(k in target[which(target %in% S1)]) { # if candidate target are in S1#
                            similar <- 1#
                            names(similar) <- k#
                            candidates <- candLink(similar = similar, candidates = candidates)#
                        }#
                        for(k in target[which(!target %in% S1)]) { # if candidate target are not in S1#
                            candidates <- KNN(taxa = k, matSim = targetSim, K = K, minSim = minSim) %>%#
                                            candLink(similar = ., candidates = candidates)#
                        }#k#
                    }#if#
                }#j#
            }#if#
#
            predictions[i, 'target_predictive'] <- candidates %>%#
                                                        .[which(.[, 'weight'] >= 0.5), 'target'] %>%#
                                                        paste(., collapse = ' | ')#
#
            # candidates <- candidates %>% .[which(.[, 'weight'] >= minWt), ] # remove candidates with a weight below MW#
            # predictions[i, 'target_predictive'] <- paste(candidates[,'target'], collapse = ' | ')#
        } #i#
    }#if#
    return(predictions)#
}#iEat
system.time(iEat_bin(S0,S1,S2,sourceSim))
qcbs_r_registration <- function(workshop=NULL,location=NULL,cancel=NULL,noshow=NULL,reregister=NULL)#
  # Get list of registrants for QCBS R workshop series#
  ##
  # Parameters:#
  ##
  # workshop = workshop number (e.g. 6), from 1-8#
  ##
  # location = Shortname for workshop location. One of "McGill", "UdeM", "Sherbrooke", "Laval", "UQAR", "UQAM", "Concordia".#
  ##
  # cancel, noshow, reregister= specify registration id to cancel a registration (cancel), indicate a person who didn't cancel#
  #                         	and didn't attend (noshow), or someone who cancelled and then decided to re-register (reregister)#
  #                         	for example: cancel=51 will cancel registration id 51. To obtain the id of a specific registration,#
  #                         	run the function with the workshop id and location name and look at the registration_id column.#
  ##
  # Output:#
  # Data frame with list of participants, or message if cancel, noshow or reregister where specified.#
  ##
  # Author:: Guillaume Larocque, 2015 (glaroc@gmail.com)#
#
  {#
	if(!is.null(cancel) | !is.null(noshow) | !is.null(reregister)){#
  	if(!is.null(cancel)){#
    	cancelnoshow=1#
    	regid=cancel#
    	status="cancel"#
  	}else if(!is.null(noshow)){#
    	cancelnoshow=2#
    	regid=noshow#
    	status="no_show"#
  	}else if(!is.null(reregister)){#
    	cancelnoshow="rereg"#
    	regid=reregister#
    	status="registered/present"#
  	}#
  	file<-postForm('http://qcbs.ca/qcbs-database/r-registration-csv.php',cancelnoshow=cancelnoshow,regid=regid,key='9HJS975LKM4FPST48SNMLE12l')#
  	print(paste('Registration ',regid,' changed to: ',status,sep=""))#
	}else{#
  	file<-postForm('http://qcbs.ca/qcbs-database/r-registration-csv.php',workshop=workshop,location=location,key='9HJS975LKM4FPST48SNMLE12l')#
  	read.csv(textConnection(file))#
	}#
}#
#Examples
class_list <- qcbs_r_registration(workshop=5,location="Laval")
library(RCurl)
class_list <- qcbs_r_registration(workshop=5,location="Laval")
class_list
class_list <- qcbs_r_registration(cancel = 1522)
class_list <- qcbs_r_registration(workshop=5,location="Laval")
class_list
qcbs_r_registration <- function(workshop=NULL,location=NULL,cancel=NULL,noshow=NULL,reregister=NULL)#
  # Get list of registrants for QCBS R workshop series#
  ##
  # Parameters:#
  ##
  # workshop = workshop number (e.g. 6), from 1-8#
  ##
  # location = Shortname for workshop location. One of "McGill", "UdeM", "Sherbrooke", "Laval", "UQAR", "UQAM", "Concordia".#
  ##
  # cancel, noshow, reregister= specify registration id to cancel a registration (cancel), indicate a person who didn't cancel#
  #                         	and didn't attend (noshow), or someone who cancelled and then decided to re-register (reregister)#
  #                         	for example: cancel=51 will cancel registration id 51. To obtain the id of a specific registration,#
  #                         	run the function with the workshop id and location name and look at the registration_id column.#
  ##
  # Output:#
  # Data frame with list of participants, or message if cancel, noshow or reregister where specified.#
  ##
  # Author:: Guillaume Larocque, 2015 (glaroc@gmail.com)#
#
  {#
	if(!is.null(cancel) | !is.null(noshow) | !is.null(reregister)){#
  	if(!is.null(cancel)){#
    	cancelnoshow=1#
    	regid=cancel#
    	status="cancel"#
  	}else if(!is.null(noshow)){#
    	cancelnoshow=2#
    	regid=noshow#
    	status="no_show"#
  	}else if(!is.null(reregister)){#
    	cancelnoshow="rereg"#
    	regid=reregister#
    	status="registered/present"#
  	}#
  	file<-postForm('http://qcbs.ca/qcbs-database/r-registration-csv.php',cancelnoshow=cancelnoshow,regid=regid,key='9HJS975LKM4FPST48SNMLE12l')#
  	print(paste('Registration ',regid,' changed to: ',status,sep=""))#
	}else{#
  	file<-postForm('http://qcbs.ca/qcbs-database/r-registration-csv.php',workshop=workshop,location=location,key='9HJS975LKM4FPST48SNMLE12l')#
  	read.csv(textConnection(file))#
	}#
}#
#Examples#
#
# ------------------------------------------------------------------------#
# ------------------------------------------------------------------------#
# ------------------------------------------------------------------------#
# ------------------------------------------------------------------------#
Pkoi l'ordre des facteurs dans la fonction ancova a de l'importance?#
# ------------------------------------------------------------------------#
# ------------------------------------------------------------------------#
# ------------------------------------------------------------------------#
# ------------------------------------------------------------------------#
#
class_list <- qcbs_r_registration(workshop=5,location="Laval")
library(RCurl)
class_list <- qcbs_r_registration(workshop=5,location="Laval")
class_list
class_list <- qcbs_r_registration(cancel = 1531)
class_list <- qcbs_r_registration(workshop=5,location="Laval")
class_list
---#
title: "Spatial characterization of stressors in the St Lawrence"#
date: "`r format(Sys.time(), '%d %B %Y')`"#
author: by David Beauchesne#
lang: english#
abstract: To be determined#
fontfamily: fourier#
linestretch: 1#
fontsize: 10pt #11pt ou 12pt#
lof: yes#
# urlcolor: magenta#
<!-- output:#
    html_document:#
        # css: ./aux/designR.css#
        highlight: zenburn#
        # “default”, “tango”, “pygments”, “kate”, “monochrome”, “espresso”, “zenburn”, “haddock”#
        theme: flatly#
        # ou “default”, “cerulean”, “journal”, “readable”, “spacelab”, “united”, “cosmo”#
        toc: yes#
    pdf_document:#
        highlight: tango#
        toc: yes#
        toc_depth: 3#
        fig_caption: yes#
        keep_tex: yes#
        latex_engine: pdflatex #xelatex#
        number_section: yes#
        includes:#
            before_body: ./aux/license.tex#
        # template: ./aux/kev_latex.tex#
    word_document:#
        #toc: yes#
        fig_caption: yes#
        highlight: pygments#
    md_document:#
        variant: markdown_strict#
bibliography: ./aux/mybiblio.bib#
#csl: ./aux/nature.csl#
#csl: ./aux/pnas.csl#
csl: ./aux/journal-of-theoretical-biology.csl#
header-includes:#
- \usepackage{fancyhdr}#
- \pagestyle{fancy}#
- \fancyhead[CO,CE]{}#
- \fancyfoot[CO,CE]{Documents dynamiques avec R Markdown}#
- \fancyfoot[LE,RO]{\thepage} -->#
---
# Run init.r before other scripts#
rm(list=ls())#
 # for use in R console.#
 # set own relevant directory if working in R console, otherwise ignore if in terminal#
setwd("/Users/davidbeauchesne/Dropbox/PhD/PhD_obj2/Structure_Comm_EGSL/Predict_interactions")#
# -----------------------------------------------------------------------------#
# PROJECT:#
#    Evaluating the structure of the communities of the estuary#
#    and gulf of St.Lawrence#
# -----------------------------------------------------------------------------#
#
# -----------------------------------------------------------------------------#
# REPOSITORY#
#   Machine learning algorithm to predict biotic interactions. This repository#
#   contains the scripts and the analyses to test the accuracy of the#
#   algorithm.#
# -----------------------------------------------------------------------------#
#
# -----------------------------------------------------------------------------#
# PROCESS STEPS:#
#   0. Setting up dataset with proper format for analysis#
##
#       0.1 Data set from RData in interactions_catalog repository#
#           Script <- file = "./Script/0-1-Tanimoto_data.r#
#           RData <- file = './RData/Tanimoto_data.RData'#
##
#       0.2 Extracting sources for each binary interaction forming the catalogue#
#           Script <- file = "./Script/0-1-Interactions_sources.r#
#           RData <- file = "./RData/interactions_source.RData")#
##
#   1. Calculating similarity matrices for resources and consumers#
#       Script <- file = './Script/1-Similarity_matrix.r'#
#       RData <- file = './RData/similarity_matrices.RData'#
##
#   2. Tanimoto analysis for XXX#
##
#       2.1 Tanimoto predictions for set of X parameters#
#           Script <- file = './Script/2-1-Tanimoto_analysis.r'#
#           RData <- file = './RData/Tanimoto_analysis.RData'#
##
#       2.2 Evaluation of analysis accuracy + tables and figures#
#           Script <- file = './Script/2-2-Tanimoto_accuracy.r'#
#           RData <- file = './RData/Tanimoto_accuracy.RData'#
#           Figures <- file = ''#
#           Tables <- file = ''#
# -----------------------------------------------------------------------------#
#
# -----------------------------------------------------------------------------#
# FUNCTIONS (add a description of the functions eventually)#
source("./Script/tanimoto.r") # basic tanimoto similarity#
source("./Script/tanimoto_traits.r") # extended tanimoto included trait/taxonomy vector#
source("./Script/similarity_taxon.r") # similarity matrix for set of taxa#
source("./Script/similarity_taxon_predict.r") #similarity of additional taxa in S1 not found in S0#
source("./Script/two_way_tanimoto_predict.r") # interaction predictions from two-way Tanimoto algorithm#
source("./Script/prediction_matrix.r") # predictions formatted to food web matrix format (S x S)#
source("./Script/empirical_matrix.r") # predictions formatted to food web matrix format (S x S)#
source("./Script/consumer_set_of_resource.r")#
source("./Script/resource_set_of_consumer.r")#
source("./Script/prediction_accuracy.r") ##
source("./Script/prediction_accuracy_id.r") ##
source("./Script/tanimoto_accuracy.r") # calculating the accuracy of predictions from Tanimoto_predictions#
source("./Script/serialNext.r") # function to avoid overwriting existing files in temporary analyses folder#
source("./Script/eplot.r") # empty plot for figure generation#
source("./Script/tanimoto_analysis.r")#
source("./Script/catalog_predictions.r") # computing prediction accuracy ~ # taxa in catalog#
source("./Script/catalog_predictions_accuracy.r") # accuracy of predictions for accuracy ~ # taxa in catalog#
source("./Script/full_algorithm.r") # full algorithm with similarity measurements included#
source("./Script/similarity_full_algorithm.r") # similarity measurements for full algorithm#
source("./Script/duplicate_row_col.r") # function to combine duplicated row and column names#
source("./Script/bin_inter.r") # function to extract binary interaction from diet matrix#
# -----------------------------------------------------------------------------#
#
# -----------------------------------------------------------------------------#
# PSEUDOCODE:#
# Parameters:#
#   Kc                    Integer, how many consumer neighbors to select#
#   Kr                    Integer, how many resource neighbors to select#
#   S0                    Interction catalogue w/ 'taxa', 'taxonomy', 'resource set', 'non-resource set', 'consumer set', 'non-consumer set'#
#   S1                    Set of taxa for which we wish to predict pairwise interactions#
#   MW                    Mimimum weight to accept a candidate as a prey#
#   Minimum_threshold     Minimum similarity threshold used to accept candidate species. Arbitrary at this point.#
##
# Output#
#   A matrix 'predictions' with columns#
#     1. S1 taxa#
#     2. empirical resource of S1 taxa#
#     3. predicted resources of S1 taxa#
##
# ------------#
##
# predictions <- empty vector#
##
##
# for consumers in S1#
#     candidate_list <- empty vector#
##
#     # 1. Empirical information in catalogue#
#     resources_S1 = set of resources found in S0#
#     empirical_resource <- empty vector#
##
#     if length(resources_S1) > 0:#
#         for resources in resources_S1#
#             if resources in S1:#
#                 add resources to empirical_resource#
#             else:#
#                 similar_resource <- pick K most similar resources in S1 based on taxonomy and set of consumers#
#                     if similarity K + 1 = similarity K:#
#                         random sample of similar resources with similarity K#
##
#                 for resources' in similar_resource#
#                     if all K similarity = 0:#
#                         break out of loop#
#                     else if resources' similarity = 0:#
#                         NULL#
#                     else if resources' similarity < minimum similarity threshold:#
#                         NULL#
#                     else if resources' in candidate_list:#
#                         add weight = similarity between resources and resources' to resources' in candidate_list#
#                     else: (not in candidate_list)#
#                         add resources' to candidate_list w/ weight = similarity between resources and resources'#
##
#         add empirical_resource to predictions matrix#
##
#     # 2. Similar consumers information#
#     similar_consumers <- pick K most similar consumers in S0 based on taxonomy and set of resources#
#         if similarity K + 1 = similarity K:#
#             random sample of similar consumers with similarity K#
##
#     for consumers' in similar_consumers#
#         if all K similarity = 0:#
#             break out of loop#
#         else if consumers' similarity = 0:#
#             NULL#
##
#         candidate_resources = resources' of consumers' in S0#
##
#         for resources' in candidate_resources#
#             if length(candidate_resources) == 0:#
#                 break out of loop#
#             else if candidate_resources == "":#
#                 break out of loop#
#             else if resources' = consumers: (does not allow for cannibalism. Should verify this at some point and allow for it, there are multiple instances of cannibalism in food webs)#
#                 break out of loop#
#             else if resources' in S1:#
#                 if resources' in candidate_list:#
#                     add weight = 1 to resources' in candidate_list#
#                 else:#
#                     add resources' w/ weight = 1 to candidate_list#
##
#             else: (resources' not in S1)#
#                 similar_resource <- pick K most similar resources in S1 based on taxonomy and set of consumers#
#                     if similarity K + 1 = similarity K:#
#                         random sample of similar resources with similarity K#
##
#                 for resources' in similar_resource#
#                     if all K similarity = 0:#
#                         break out of loop#
#                     else if resources' similarity = 0:#
#                         NULL#
#                     else if resources' similarity < minimum similarity threshold:#
#                         NULL#
#                     else if resources' in candidate_list:#
#                         add weight = similarity between resources' and candidate_resources to resources' in candidate_list#
#                     else: (not in candidate_list)#
#                         add resources' to candidate_list w/ weight = similarity between resources' and candidate_resources#
##
#     candidate_list <- choose candidate resources with weight >= MW#
#     predictions <- add candidate_list to predictions#
##
# return(predictions matrix)
load("./RData/interactions_source.RData")#
filename1 = 'catalog_predictions2'#
filename2 = 'catalog_predictions3'#
filename3 = 'catalog_predictions4'
# Catalog vs predictions#
load("./Analyses/catalog_predictions0.RData")#
catalog_predictions0 <- Tanimoto_analysis#
load("./Analyses/catalog_predictions1.RData")#
catalog_predictions1 <- Tanimoto_analysis#
load("./Analyses/catalog_predictions2.RData")#
catalog_predictions2 <- Tanimoto_analysis#
load("./Analyses/catalog_predictions3.RData")#
catalog_predictions3 <- Tanimoto_analysis#
load("./Analyses/catalog_predictions4.RData")#
catalog_predictions4 <- Tanimoto_analysis#
#
accuracy <- accuracy0 <- accuracy1 <- accuracy2 <- accuracy3 <- vector('list', 3)#
names(accuracy) <- names(accuracy0) <- names(accuracy1) <- names(accuracy2) <- c('Catalog', 'Predict', 'Algorithm')#
accuracy[[1]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions2, empirical.only = TRUE)#
accuracy[[2]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions2, predict.only = TRUE)#
accuracy[[3]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions2)#
#
accuracy0[[1]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions0, empirical.only = TRUE)#
accuracy0[[2]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions0, predict.only = TRUE)#
accuracy0[[3]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions0)#
#
accuracy1[[1]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions1, empirical.only = TRUE)#
accuracy1[[2]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions1, predict.only = TRUE)#
accuracy1[[3]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions1)#
#
accuracy2[[1]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions3, empirical.only = TRUE)#
accuracy2[[2]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions3, predict.only = TRUE)#
accuracy2[[3]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions3)#
#
accuracy3[[1]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions4, empirical.only = TRUE)#
accuracy3[[2]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions4, predict.only = TRUE)#
accuracy3[[3]] <- catalog_predictions_accuracy(Tanimoto_analysis = catalog_predictions4)#
#
accuracy[[1]] <- rbind(accuracy[[1]], accuracy0[[1]], accuracy1[[1]], accuracy2[[1]], accuracy3[[1]])#
accuracy[[2]] <- rbind(accuracy[[2]], accuracy0[[2]], accuracy1[[2]], accuracy2[[2]], accuracy3[[2]])#
accuracy[[3]] <- rbind(accuracy[[3]], accuracy0[[3]], accuracy1[[3]], accuracy2[[3]], accuracy3[[3]])#
#
percent_remove = c(0,10,20,30,40,50,60,70,80,90,100)#
nb_iter = 50#
K.values = 8#
MW = 1#
WT =  c(0.5,1)#
minimum_threshold = 0.3#
#
nb.pts <- length(percent_remove)
j = 14 #'Score'[y]#
        eplot(xmin = -1, xmax = 100 + 1, ymax = 3.6)#
        par(pch = 21,  xaxs = "i", yaxs = "i", family = "serif")#
        col <- c("gray",'gray','gray')#
        col2 <- c("black",'black','black')#
        col3 <- c("black","black","black")#
#
        # Axes#
            axis(side = 1, at = seq(0, 100, by = 10), labels = FALSE, las = 1, pos = -0.05)#
            axis(side = 2, at = seq(0, 1, by = 0.25), labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 2, at = seq(0, 1, by = 0.25)+1.25, labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 2, at = seq(0, 1, by = 0.25)+2.5, labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 3, at = seq(0, 100, by = 10), labels = FALSE, las = 1, pos = 1.05 + 2.5)#
            axis(side = 4, at = seq(0, 1, by = 0.25), labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 4, at = seq(0, 1, by = 0.25)+1.25, labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 4, at = seq(0, 1, by = 0.25)+2.5, labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
#
            abline(h = c(1.125,2.375), col = "gray", lty = 2)#
            mtext(text = expression('Score'[y]), side = 2, line = 2, at = 1.75, font = 1.5, cex = 1)#
            mtext(text = expression(paste("Percent of ",italic(N[1])," taxa in ", italic(N[0]), ' (%)')), side = 1, line = 2, at = 50, font = 2, cex = 1)#
            mtext(text = expression(paste("Percent of taxa removed from ", italic(N[0]), ' (%)')), side = 3, line = 1, at = 50, font = 2, cex = 1)#
            mtext(text = seq(100, 0, by = -10), side = 1, line = 0, at = seq(0, 100, by = 10), font = 1, cex = 0.75)#
            mtext(text = seq(0, 100, by = 10), side = 3, line = -0.5, at = seq(0, 100, by = 10), font = 1, cex = 0.75)#
            text(x = 5, y = 0.85, labels = 'Catalogue', font = 2, cex = 1, col = col3[1], adj = 0)#
            text(x = 5, y = 2.10, labels = 'Predictions', font = 2, cex = 1, col = col3[2], adj = 0)#
            text(x = 5, y = 3.35, labels = 'Algorithm', font = 2, cex = 1, col = col3[3], adj = 0)#
#
        it <- 0#
        for(i in 1:length(accuracy)) {#
            if(i == 2 || i == 3) {#
                accuracy_mean <- aggregate(as.numeric(accuracy[[i]][,j]) ~ as.numeric(accuracy[[i]][, 'pc_rm']) + as.numeric(accuracy[[i]][, 'wt']), data=accuracy[[i]], FUN=function(x) c(mean=mean(x), sd=sd(x)))#
                accuracy_mean <- accuracy_mean[order(accuracy_mean[,2]), ]#
                # hack: we draw arrows but with very special "arrowheads" for error bars#
#
                arrows(seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][,1] - accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 1] + accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 2]+it), length=0.025, angle=90, code=3, col = col[i])#
                points(x = seq(0,100,by=10), y = rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 1]+it), cex = 0.75, pch = 22, col = col[i])#
#
                arrows(seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][,1] - accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 1] + accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 2]+it), length=0.025, angle=90, code=3, col = col2[i])#
                points(x = seq(0,100,by=10), y = rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 1]+it), cex = 0.75, pch = 22, col = col2[i])#
#
                lines(lowess(x = as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '0.5'), 'pc_rm']), y = rev(as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '0.5'), j]) + it)), col = col[i])#
                lines(lowess(x = as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '1'), 'pc_rm']), y = rev(as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '1'), j]) + it)), col = col2[i])#
#
                text(x = 90, y = 0.25 + it, labels = expression(paste(italic('w'[t]), ' = 0.5')), col = col[i], font = 1, cex = 0.75)#
                text(x = 90, y = 0.15 + it, labels = expression(paste(italic('w'[t]), ' = 1')), col = col2[i], font = 1, cex = 0.75)#
                } else {#
                    accuracy_mean <- aggregate(as.numeric(accuracy[[i]][,j]) ~ as.numeric(accuracy[[i]][, 'pc_rm']), data=accuracy[[i]], FUN=function(x) c(mean=mean(x), sd=sd(x)))#
                    accuracy_mean <- accuracy_mean[order(accuracy_mean[,1]), ]#
                    # hack: we draw arrows but with very special "arrowheads" for error bars#
#
                    arrows(seq(0,100,by=10), rev(accuracy_mean[, 2][,1] - accuracy_mean[, 2][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[, 2][, 1] + accuracy_mean[, 2][, 2]+it), length=0.025, angle=90, code=3, col = col3[i])#
                    points(x = seq(0,100,by=10), y = rev(accuracy_mean[, 2][, 1]+it), cex = 0.75, pch = 22, col = col3[i])#
#
                    lines(lowess(x = as.numeric(accuracy[[i]][, 'pc_rm']), y = rev(as.numeric(accuracy[[i]][, j]) + it)), col = col3[i])#
                }#
#
            it <- it + 1.25#
        } #i
j = 14 #'Score'[y]#
        eplot(xmin = -1, xmax = 100 + 1, ymax = 3.6)#
        par(pch = 21,  xaxs = "i", yaxs = "i", family = "serif")#
        col <- c("dark gray",'dark gray','dark gray')#
        col2 <- c("black",'black','black')#
        col3 <- c("black","black","black")#
#
        # Axes#
            axis(side = 1, at = seq(0, 100, by = 10), labels = FALSE, las = 1, pos = -0.05)#
            axis(side = 2, at = seq(0, 1, by = 0.25), labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 2, at = seq(0, 1, by = 0.25)+1.25, labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 2, at = seq(0, 1, by = 0.25)+2.5, labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 3, at = seq(0, 100, by = 10), labels = FALSE, las = 1, pos = 1.05 + 2.5)#
            axis(side = 4, at = seq(0, 1, by = 0.25), labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 4, at = seq(0, 1, by = 0.25)+1.25, labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 4, at = seq(0, 1, by = 0.25)+2.5, labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
#
            abline(h = c(1.125,2.375), col = "gray", lty = 2)#
            mtext(text = expression('Score'[y]), side = 2, line = 2, at = 1.75, font = 1.5, cex = 1)#
            mtext(text = expression(paste("Percent of ",italic(N[1])," taxa in ", italic(N[0]), ' (%)')), side = 1, line = 2, at = 50, font = 2, cex = 1)#
            mtext(text = expression(paste("Percent of taxa removed from ", italic(N[0]), ' (%)')), side = 3, line = 1, at = 50, font = 2, cex = 1)#
            mtext(text = seq(100, 0, by = -10), side = 1, line = 0, at = seq(0, 100, by = 10), font = 1, cex = 0.75)#
            mtext(text = seq(0, 100, by = 10), side = 3, line = -0.5, at = seq(0, 100, by = 10), font = 1, cex = 0.75)#
            text(x = 5, y = 0.85, labels = 'Catalogue', font = 2, cex = 1, col = col3[1], adj = 0)#
            text(x = 5, y = 2.10, labels = 'Predictions', font = 2, cex = 1, col = col3[2], adj = 0)#
            text(x = 5, y = 3.35, labels = 'Algorithm', font = 2, cex = 1, col = col3[3], adj = 0)#
#
        it <- 0#
        for(i in 1:length(accuracy)) {#
            if(i == 2 || i == 3) {#
                accuracy_mean <- aggregate(as.numeric(accuracy[[i]][,j]) ~ as.numeric(accuracy[[i]][, 'pc_rm']) + as.numeric(accuracy[[i]][, 'wt']), data=accuracy[[i]], FUN=function(x) c(mean=mean(x), sd=sd(x)))#
                accuracy_mean <- accuracy_mean[order(accuracy_mean[,2]), ]#
                # hack: we draw arrows but with very special "arrowheads" for error bars#
#
                arrows(seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][,1] - accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 1] + accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 2]+it), length=0.025, angle=90, code=3, col = col[i])#
                points(x = seq(0,100,by=10), y = rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 1]+it), cex = 0.75, pch = 22, col = col[i])#
#
                arrows(seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][,1] - accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 1] + accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 2]+it), length=0.025, angle=90, code=3, col = col2[i])#
                points(x = seq(0,100,by=10), y = rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 1]+it), cex = 0.75, pch = 22, col = col2[i])#
#
                lines(lowess(x = as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '0.5'), 'pc_rm']), y = rev(as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '0.5'), j]) + it)), col = col[i])#
                lines(lowess(x = as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '1'), 'pc_rm']), y = rev(as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '1'), j]) + it)), col = col2[i])#
#
                text(x = 90, y = 0.25 + it, labels = expression(paste(italic('w'[t]), ' = 0.5')), col = col[i], font = 1, cex = 0.75)#
                text(x = 90, y = 0.15 + it, labels = expression(paste(italic('w'[t]), ' = 1')), col = col2[i], font = 1, cex = 0.75)#
                } else {#
                    accuracy_mean <- aggregate(as.numeric(accuracy[[i]][,j]) ~ as.numeric(accuracy[[i]][, 'pc_rm']), data=accuracy[[i]], FUN=function(x) c(mean=mean(x), sd=sd(x)))#
                    accuracy_mean <- accuracy_mean[order(accuracy_mean[,1]), ]#
                    # hack: we draw arrows but with very special "arrowheads" for error bars#
#
                    arrows(seq(0,100,by=10), rev(accuracy_mean[, 2][,1] - accuracy_mean[, 2][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[, 2][, 1] + accuracy_mean[, 2][, 2]+it), length=0.025, angle=90, code=3, col = col3[i])#
                    points(x = seq(0,100,by=10), y = rev(accuracy_mean[, 2][, 1]+it), cex = 0.75, pch = 22, col = col3[i])#
#
                    lines(lowess(x = as.numeric(accuracy[[i]][, 'pc_rm']), y = rev(as.numeric(accuracy[[i]][, j]) + it)), col = col3[i])#
                }#
#
            it <- it + 1.25#
        } #i
?lty
?pch
?lines
j = 14 #'Score'[y]#
        eplot(xmin = -1, xmax = 100 + 1, ymax = 3.6)#
        par(pch = 21,  xaxs = "i", yaxs = "i", family = "serif")#
        col <- c("dark gray",'dark gray','dark gray')#
        col2 <- c("black",'black','black')#
        col3 <- c("black","black","black")#
#
        # Axes#
            axis(side = 1, at = seq(0, 100, by = 10), labels = FALSE, las = 1, pos = -0.05)#
            axis(side = 2, at = seq(0, 1, by = 0.25), labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 2, at = seq(0, 1, by = 0.25)+1.25, labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 2, at = seq(0, 1, by = 0.25)+2.5, labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 3, at = seq(0, 100, by = 10), labels = FALSE, las = 1, pos = 1.05 + 2.5)#
            axis(side = 4, at = seq(0, 1, by = 0.25), labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 4, at = seq(0, 1, by = 0.25)+1.25, labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 4, at = seq(0, 1, by = 0.25)+2.5, labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
#
            abline(h = c(1.125,2.375), col = "gray", lty = 2)#
            mtext(text = expression('Score'[y]), side = 2, line = 2, at = 1.75, font = 1.5, cex = 1)#
            mtext(text = expression(paste("Percent of ",italic(N[1])," taxa in ", italic(N[0]), ' (%)')), side = 1, line = 2, at = 50, font = 2, cex = 1)#
            mtext(text = expression(paste("Percent of taxa removed from ", italic(N[0]), ' (%)')), side = 3, line = 1, at = 50, font = 2, cex = 1)#
            mtext(text = seq(100, 0, by = -10), side = 1, line = 0, at = seq(0, 100, by = 10), font = 1, cex = 0.75)#
            mtext(text = seq(0, 100, by = 10), side = 3, line = -0.5, at = seq(0, 100, by = 10), font = 1, cex = 0.75)#
            text(x = 5, y = 0.85, labels = 'Catalogue', font = 2, cex = 1, col = col3[1], adj = 0)#
            text(x = 5, y = 2.10, labels = 'Predictions', font = 2, cex = 1, col = col3[2], adj = 0)#
            text(x = 5, y = 3.35, labels = 'Algorithm', font = 2, cex = 1, col = col3[3], adj = 0)#
#
        it <- 0#
        for(i in 1:length(accuracy)) {#
            if(i == 2 || i == 3) {#
                accuracy_mean <- aggregate(as.numeric(accuracy[[i]][,j]) ~ as.numeric(accuracy[[i]][, 'pc_rm']) + as.numeric(accuracy[[i]][, 'wt']), data=accuracy[[i]], FUN=function(x) c(mean=mean(x), sd=sd(x)))#
                accuracy_mean <- accuracy_mean[order(accuracy_mean[,2]), ]#
                # hack: we draw arrows but with very special "arrowheads" for error bars#
#
                arrows(seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][,1] - accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 1] + accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 2]+it), length=0.025, angle=90, code=3, col = col[i])#
                points(x = seq(0,100,by=10), y = rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 1]+it), cex = 0.75, pch = 22, col = col[i])#
#
                arrows(seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][,1] - accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 1] + accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 2]+it), length=0.025, angle=90, code=3, col = col2[i])#
                points(x = seq(0,100,by=10), y = rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 1]+it), cex = 0.75, pch = 22, col = col2[i])#
#
                lines(lowess(x = as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '0.5'), 'pc_rm']), y = rev(as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '0.5'), j]) + it)), col = col[i], lty = 3)#
                lines(lowess(x = as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '1'), 'pc_rm']), y = rev(as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '1'), j]) + it)), col = col2[i])#
#
                text(x = 90, y = 0.25 + it, labels = expression(paste(italic('w'[t]), ' = 0.5')), col = col[i], font = 1, cex = 0.75)#
                text(x = 90, y = 0.15 + it, labels = expression(paste(italic('w'[t]), ' = 1')), col = col2[i], font = 1, cex = 0.75)#
                } else {#
                    accuracy_mean <- aggregate(as.numeric(accuracy[[i]][,j]) ~ as.numeric(accuracy[[i]][, 'pc_rm']), data=accuracy[[i]], FUN=function(x) c(mean=mean(x), sd=sd(x)))#
                    accuracy_mean <- accuracy_mean[order(accuracy_mean[,1]), ]#
                    # hack: we draw arrows but with very special "arrowheads" for error bars#
#
                    arrows(seq(0,100,by=10), rev(accuracy_mean[, 2][,1] - accuracy_mean[, 2][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[, 2][, 1] + accuracy_mean[, 2][, 2]+it), length=0.025, angle=90, code=3, col = col3[i])#
                    points(x = seq(0,100,by=10), y = rev(accuracy_mean[, 2][, 1]+it), cex = 0.75, pch = 22, col = col3[i])#
#
                    lines(lowess(x = as.numeric(accuracy[[i]][, 'pc_rm']), y = rev(as.numeric(accuracy[[i]][, j]) + it)), col = col3[i])#
                }#
#
            it <- it + 1.25#
        } #i
j = 14 #'Score'[y]#
        eplot(xmin = -1, xmax = 100 + 1, ymax = 3.6)#
        par(pch = 21,  xaxs = "i", yaxs = "i", family = "serif")#
        col <- c("dark gray",'dark gray','dark gray')#
        col2 <- c("black",'black','black')#
        col3 <- c("black","black","black")#
#
        # Axes#
            axis(side = 1, at = seq(0, 100, by = 10), labels = FALSE, las = 1, pos = -0.05)#
            axis(side = 2, at = seq(0, 1, by = 0.25), labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 2, at = seq(0, 1, by = 0.25)+1.25, labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 2, at = seq(0, 1, by = 0.25)+2.5, labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 3, at = seq(0, 100, by = 10), labels = FALSE, las = 1, pos = 1.05 + 2.5)#
            axis(side = 4, at = seq(0, 1, by = 0.25), labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 4, at = seq(0, 1, by = 0.25)+1.25, labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 4, at = seq(0, 1, by = 0.25)+2.5, labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
#
            abline(h = c(1.125,2.375), col = "gray", lty = 2)#
            mtext(text = expression('Score'[y]), side = 2, line = 2, at = 1.75, font = 1.5, cex = 1)#
            mtext(text = expression(paste("Percent of ",italic(N[1])," taxa in ", italic(N[0]), ' (%)')), side = 1, line = 2, at = 50, font = 2, cex = 1)#
            mtext(text = expression(paste("Percent of taxa removed from ", italic(N[0]), ' (%)')), side = 3, line = 1, at = 50, font = 2, cex = 1)#
            mtext(text = seq(100, 0, by = -10), side = 1, line = 0, at = seq(0, 100, by = 10), font = 1, cex = 0.75)#
            mtext(text = seq(0, 100, by = 10), side = 3, line = -0.5, at = seq(0, 100, by = 10), font = 1, cex = 0.75)#
            text(x = 5, y = 0.85, labels = 'Catalogue', font = 2, cex = 1, col = col3[1], adj = 0)#
            text(x = 5, y = 2.10, labels = 'Predictions', font = 2, cex = 1, col = col3[2], adj = 0)#
            text(x = 5, y = 3.35, labels = 'Algorithm', font = 2, cex = 1, col = col3[3], adj = 0)#
#
        it <- 0#
        for(i in 1:length(accuracy)) {#
            if(i == 2 || i == 3) {#
                accuracy_mean <- aggregate(as.numeric(accuracy[[i]][,j]) ~ as.numeric(accuracy[[i]][, 'pc_rm']) + as.numeric(accuracy[[i]][, 'wt']), data=accuracy[[i]], FUN=function(x) c(mean=mean(x), sd=sd(x)))#
                accuracy_mean <- accuracy_mean[order(accuracy_mean[,2]), ]#
                # hack: we draw arrows but with very special "arrowheads" for error bars#
#
                arrows(seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][,1] - accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 1] + accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 2]+it), length=0.025, angle=90, code=3, col = col[i])#
                points(x = seq(0,100,by=10), y = rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 1]+it), cex = 0.75, pch = 22, col = col[i])#
#
                arrows(seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][,1] - accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 1] + accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 2]+it), length=0.025, angle=90, code=3, col = col2[i])#
                points(x = seq(0,100,by=10), y = rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 1]+it), cex = 0.75, pch = 22, col = col2[i])#
#
                lines(lowess(x = as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '0.5'), 'pc_rm']), y = rev(as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '0.5'), j]) + it)), col = col[i], lty = 4)#
                lines(lowess(x = as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '1'), 'pc_rm']), y = rev(as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '1'), j]) + it)), col = col2[i])#
#
                text(x = 90, y = 0.25 + it, labels = expression(paste(italic('w'[t]), ' = 0.5')), col = col[i], font = 1, cex = 0.75)#
                text(x = 90, y = 0.15 + it, labels = expression(paste(italic('w'[t]), ' = 1')), col = col2[i], font = 1, cex = 0.75)#
                } else {#
                    accuracy_mean <- aggregate(as.numeric(accuracy[[i]][,j]) ~ as.numeric(accuracy[[i]][, 'pc_rm']), data=accuracy[[i]], FUN=function(x) c(mean=mean(x), sd=sd(x)))#
                    accuracy_mean <- accuracy_mean[order(accuracy_mean[,1]), ]#
                    # hack: we draw arrows but with very special "arrowheads" for error bars#
#
                    arrows(seq(0,100,by=10), rev(accuracy_mean[, 2][,1] - accuracy_mean[, 2][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[, 2][, 1] + accuracy_mean[, 2][, 2]+it), length=0.025, angle=90, code=3, col = col3[i])#
                    points(x = seq(0,100,by=10), y = rev(accuracy_mean[, 2][, 1]+it), cex = 0.75, pch = 22, col = col3[i])#
#
                    lines(lowess(x = as.numeric(accuracy[[i]][, 'pc_rm']), y = rev(as.numeric(accuracy[[i]][, j]) + it)), col = col3[i])#
                }#
#
            it <- it + 1.25#
        } #i
jpeg(paste('./Article/Revisions/','Figure3_BW','.jpeg',sep=''),width=6,height=8, res = 300, units = 'in')#
j = 14 #'Score'[y]#
        eplot(xmin = -1, xmax = 100 + 1, ymax = 3.6)#
        par(pch = 21,  xaxs = "i", yaxs = "i", family = "serif")#
        col <- c("dark gray",'dark gray','dark gray')#
        col2 <- c("black",'black','black')#
        col3 <- c("black","black","black")#
#
        # Axes#
            axis(side = 1, at = seq(0, 100, by = 10), labels = FALSE, las = 1, pos = -0.05)#
            axis(side = 2, at = seq(0, 1, by = 0.25), labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 2, at = seq(0, 1, by = 0.25)+1.25, labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 2, at = seq(0, 1, by = 0.25)+2.5, labels = seq(0, 1, by = 0.25), las = 1, pos = -1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 3, at = seq(0, 100, by = 10), labels = FALSE, las = 1, pos = 1.05 + 2.5)#
            axis(side = 4, at = seq(0, 1, by = 0.25), labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 4, at = seq(0, 1, by = 0.25)+1.25, labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
            axis(side = 4, at = seq(0, 1, by = 0.25)+2.5, labels = seq(0, 1, by = 0.25), las = 1, pos = 100 + 1, cex.axis = 0.75, font.axis = 1)#
#
            abline(h = c(1.125,2.375), col = "gray", lty = 2)#
            mtext(text = expression('Score'[y]), side = 2, line = 2, at = 1.75, font = 1.5, cex = 1)#
            mtext(text = expression(paste("Percent of ",italic(N[1])," taxa in ", italic(N[0]), ' (%)')), side = 1, line = 2, at = 50, font = 2, cex = 1)#
            mtext(text = expression(paste("Percent of taxa removed from ", italic(N[0]), ' (%)')), side = 3, line = 1, at = 50, font = 2, cex = 1)#
            mtext(text = seq(100, 0, by = -10), side = 1, line = 0, at = seq(0, 100, by = 10), font = 1, cex = 0.75)#
            mtext(text = seq(0, 100, by = 10), side = 3, line = -0.5, at = seq(0, 100, by = 10), font = 1, cex = 0.75)#
            text(x = 5, y = 0.85, labels = 'Catalogue', font = 2, cex = 1, col = col3[1], adj = 0)#
            text(x = 5, y = 2.10, labels = 'Predictions', font = 2, cex = 1, col = col3[2], adj = 0)#
            text(x = 5, y = 3.35, labels = 'Algorithm', font = 2, cex = 1, col = col3[3], adj = 0)#
#
        it <- 0#
        for(i in 1:length(accuracy)) {#
            if(i == 2 || i == 3) {#
                accuracy_mean <- aggregate(as.numeric(accuracy[[i]][,j]) ~ as.numeric(accuracy[[i]][, 'pc_rm']) + as.numeric(accuracy[[i]][, 'wt']), data=accuracy[[i]], FUN=function(x) c(mean=mean(x), sd=sd(x)))#
                accuracy_mean <- accuracy_mean[order(accuracy_mean[,2]), ]#
                # hack: we draw arrows but with very special "arrowheads" for error bars#
#
                arrows(seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][,1] - accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 1] + accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 2]+it), length=0.025, angle=90, code=3, col = col[i])#
                points(x = seq(0,100,by=10), y = rev(accuracy_mean[which(accuracy_mean[, 2] == '0.5'), 3][, 1]+it), cex = 0.75, pch = 22, col = col[i])#
#
                arrows(seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][,1] - accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 1] + accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 2]+it), length=0.025, angle=90, code=3, col = col2[i])#
                points(x = seq(0,100,by=10), y = rev(accuracy_mean[which(accuracy_mean[, 2] == '1'), 3][, 1]+it), cex = 0.75, pch = 22, col = col2[i])#
#
                lines(lowess(x = as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '0.5'), 'pc_rm']), y = rev(as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '0.5'), j]) + it)), col = col[i], lty = 4)#
                lines(lowess(x = as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '1'), 'pc_rm']), y = rev(as.numeric(accuracy[[i]][which(accuracy[[i]][, 'wt'] == '1'), j]) + it)), col = col2[i])#
#
                text(x = 90, y = 0.25 + it, labels = expression(paste(italic('w'[t]), ' = 0.5')), col = col[i], font = 1, cex = 0.75)#
                text(x = 90, y = 0.15 + it, labels = expression(paste(italic('w'[t]), ' = 1')), col = col2[i], font = 1, cex = 0.75)#
                } else {#
                    accuracy_mean <- aggregate(as.numeric(accuracy[[i]][,j]) ~ as.numeric(accuracy[[i]][, 'pc_rm']), data=accuracy[[i]], FUN=function(x) c(mean=mean(x), sd=sd(x)))#
                    accuracy_mean <- accuracy_mean[order(accuracy_mean[,1]), ]#
                    # hack: we draw arrows but with very special "arrowheads" for error bars#
#
                    arrows(seq(0,100,by=10), rev(accuracy_mean[, 2][,1] - accuracy_mean[, 2][, 2]+it), seq(0,100,by=10), rev(accuracy_mean[, 2][, 1] + accuracy_mean[, 2][, 2]+it), length=0.025, angle=90, code=3, col = col3[i])#
                    points(x = seq(0,100,by=10), y = rev(accuracy_mean[, 2][, 1]+it), cex = 0.75, pch = 22, col = col3[i])#
#
                    lines(lowess(x = as.numeric(accuracy[[i]][, 'pc_rm']), y = rev(as.numeric(accuracy[[i]][, j]) + it)), col = col3[i])#
                }#
#
            it <- it + 1.25#
        } #i#
dev.off()
library(DiagrammeR)#
grViz("#
#
digraph boxes_and_circles{#
#
    node [shape = box#
            # fixedsize = TRUE#
            # width = 2.5#
            ]#
            1 [label =  <Skates>]#
            2 [label =  <Cetaceans>]#
            3 [label =  <Hooded seals>]#
            4 [label =  <Atlantic cod>]#
            5 [label =  <Grey seals>]#
            6 [label =  <Harp seals>]#
            7 [label =  <Seabirds>]#
            8 [label =  <Harbour seals>]#
            9 [label =  <Greenland halibut>]#
            10 [label =  <Piscivorous small<br/>pelagic feeders>]#
            11 [label =  <Redfish>]#
            12 [label =  <Large pelagic<br/>feeders>]#
            13 [label =  <Large demersal<br/>feeders>]#
            14 [label =  <Capelin>]#
            15 [label =  <Small demersal<br/>feeders>]#
            16 [label =  <Planktivorous small<br/>pelagic feeders>]#
            17 [label =  <Small zooplankton>]#
            18 [label =  <Flounders>]#
            19 [label =  <Large crustaceans>]#
            20 [label =  <American plaice>]#
            21 [label =  <Shrimp>]#
#
    edge [dir = back]#
            12 -> 15 [color = 'transparent']#
            12 -> 16 [color = 'transparent']#
            13 -> 15 [color = 'transparent']#
            13 -> 16 [color = 'transparent']#
            20 -> 15 [color = 'transparent']#
            20 -> 16 [color = 'transparent']#
            18 -> 15 [color = 'transparent']#
            18 -> 16 [color = 'transparent']#
            4 -> 15 [color = 'transparent']#
            4 -> 16 [color = 'transparent']#
            15 -> 21 [color = 'transparent']#
            15 -> 19 [color = 'transparent']#
            16 -> 21 [color = 'transparent']#
            16 -> 19 [color = 'transparent']#
#
            2 -> 11 [color = 'transparent']#
            2 -> 1 [color = 'transparent']#
            2 -> 9 [color = 'transparent']#
            3 -> 11 [color = 'transparent']#
            3 -> 1 [color = 'transparent']#
            3 -> 9 [color = 'transparent']#
            5 -> 11 [color = 'transparent']#
            5 -> 1 [color = 'transparent']#
            5 -> 9 [color = 'transparent']#
            6 -> 11 [color = 'transparent']#
            6 -> 1 [color = 'transparent']#
            6 -> 9 [color = 'transparent']#
#
            #Empirical & predictions#
            1 -> 10 [color = 'green']#
            2 -> 10 [color = 'green']#
            3 -> 10 [color = 'green']#
            4 -> 10 [color = 'green']#
            6 -> 10 [color = 'green']#
            7 -> 10 [color = 'green']#
            8 -> 10 [color = 'green']#
            10 -> 16 [color = 'green']#
            10 -> 14 [color = 'green']#
            10 -> 17 [color = 'green']#
            12 -> 10 [color = 'green']#
            13 -> 10 [color = 'green']#
            1 -> 14 [color = 'green']#
            2 -> 14 [color = 'green']#
            3 -> 14 [color = 'green']#
            4 -> 14 [color = 'green']#
            5 -> 14 [color = 'green']#
            14 -> 17 [color = 'green']#
            15 -> 14 [color = 'green']#
            6 -> 14 [color = 'green']#
            7 -> 14 [color = 'green']#
            8 -> 14 [color = 'green']#
            9 -> 14 [color = 'green']#
            11 -> 14 [color = 'green']#
            12 -> 14 [color = 'green']#
            13 -> 14 [color = 'green']#
#
            # Empirical only#
            5 -> 10 [color = 'black']#
            9 -> 10 [color = 'black']#
            11 -> 10 [color = 'black']#
#
            # Predictions only#
            18 -> 10 [color = 'blue']#
            15 -> 10 [color = 'blue']#
            10 -> 21 [color = 'blue']#
            10 -> 4 [color = 'blue']#
            10 -> 18 [color = 'blue']#
            10 -> 15 [color = 'blue']#
            10 -> 10 [color = 'blue']#
            10 -> 12 [color = 'blue']#
            10 -> 13 [color = 'blue']#
            19 -> 14 [color = 'blue']#
            16 -> 14 [color = 'blue']#
            20 -> 14 [color = 'blue']#
            18 -> 14 [color = 'blue']#
            14 -> 14 [color = 'blue']#
            16 -> 10 [color = 'blue']#
            20 -> 10 [color = 'blue']#
            10 -> 19 [color = 'blue']#
            10 -> 20 [color = 'blue']#
            10 -> 9 [color = 'blue']#
}#
")
# Figure 4 - article B&W#
library(DiagrammeR)#
grViz("#
#
digraph boxes_and_circles{#
#
    node [shape = box#
            # fixedsize = TRUE#
            # width = 2.5#
            ]#
            1 [label =  <Skates>]#
            2 [label =  <Cetaceans>]#
            3 [label =  <Hooded seals>]#
            4 [label =  <Atlantic cod>]#
            5 [label =  <Grey seals>]#
            6 [label =  <Harp seals>]#
            7 [label =  <Seabirds>]#
            8 [label =  <Harbour seals>]#
            9 [label =  <grayland halibut>]#
            10 [label =  <Piscivorous small<br/>pelagic feeders>]#
            11 [label =  <Redfish>]#
            12 [label =  <Large pelagic<br/>feeders>]#
            13 [label =  <Large demersal<br/>feeders>]#
            14 [label =  <Capelin>]#
            15 [label =  <Small demersal<br/>feeders>]#
            16 [label =  <Planktivorous small<br/>pelagic feeders>]#
            17 [label =  <Small zooplankton>]#
            18 [label =  <Flounders>]#
            19 [label =  <Large crustaceans>]#
            20 [label =  <American plaice>]#
            21 [label =  <Shrimp>]#
#
    edge [dir = back]#
            12 -> 15 [color = 'transparent']#
            12 -> 16 [color = 'transparent']#
            13 -> 15 [color = 'transparent']#
            13 -> 16 [color = 'transparent']#
            20 -> 15 [color = 'transparent']#
            20 -> 16 [color = 'transparent']#
            18 -> 15 [color = 'transparent']#
            18 -> 16 [color = 'transparent']#
            4 -> 15 [color = 'transparent']#
            4 -> 16 [color = 'transparent']#
            15 -> 21 [color = 'transparent']#
            15 -> 19 [color = 'transparent']#
            16 -> 21 [color = 'transparent']#
            16 -> 19 [color = 'transparent']#
#
            2 -> 11 [color = 'transparent']#
            2 -> 1 [color = 'transparent']#
            2 -> 9 [color = 'transparent']#
            3 -> 11 [color = 'transparent']#
            3 -> 1 [color = 'transparent']#
            3 -> 9 [color = 'transparent']#
            5 -> 11 [color = 'transparent']#
            5 -> 1 [color = 'transparent']#
            5 -> 9 [color = 'transparent']#
            6 -> 11 [color = 'transparent']#
            6 -> 1 [color = 'transparent']#
            6 -> 9 [color = 'transparent']#
#
            #Empirical & predictions#
            1 -> 10 [color = 'gray']#
            2 -> 10 [color = 'gray']#
            3 -> 10 [color = 'gray']#
            4 -> 10 [color = 'gray']#
            6 -> 10 [color = 'gray']#
            7 -> 10 [color = 'gray']#
            8 -> 10 [color = 'gray']#
            10 -> 16 [color = 'gray']#
            10 -> 14 [color = 'gray']#
            10 -> 17 [color = 'gray']#
            12 -> 10 [color = 'gray']#
            13 -> 10 [color = 'gray']#
            1 -> 14 [color = 'gray']#
            2 -> 14 [color = 'gray']#
            3 -> 14 [color = 'gray']#
            4 -> 14 [color = 'gray']#
            5 -> 14 [color = 'gray']#
            14 -> 17 [color = 'gray']#
            15 -> 14 [color = 'gray']#
            6 -> 14 [color = 'gray']#
            7 -> 14 [color = 'gray']#
            8 -> 14 [color = 'gray']#
            9 -> 14 [color = 'gray']#
            11 -> 14 [color = 'gray']#
            12 -> 14 [color = 'gray']#
            13 -> 14 [color = 'gray']#
#
            # Empirical only#
            5 -> 10 [color = 'black']#
            9 -> 10 [color = 'black']#
            11 -> 10 [color = 'black']#
#
            # Predictions only#
            18 -> 10 [color = 'gray', style = 'dotted']#
            15 -> 10 [color = 'gray', style = 'dotted']#
            10 -> 21 [color = 'gray', style = 'dotted']#
            10 -> 4 [color = 'gray', style = 'dotted']#
            10 -> 18 [color = 'gray', style = 'dotted']#
            10 -> 15 [color = 'gray', style = 'dotted']#
            10 -> 10 [color = 'gray', style = 'dotted']#
            10 -> 12 [color = 'gray', style = 'dotted']#
            10 -> 13 [color = 'gray', style = 'dotted']#
            19 -> 14 [color = 'gray', style = 'dotted']#
            16 -> 14 [color = 'gray', style = 'dotted']#
            20 -> 14 [color = 'gray', style = 'dotted']#
            18 -> 14 [color = 'gray', style = 'dotted']#
            14 -> 14 [color = 'gray', style = 'dotted']#
            16 -> 10 [color = 'gray', style = 'dotted']#
            20 -> 10 [color = 'gray', style = 'dotted']#
            10 -> 19 [color = 'gray', style = 'dotted']#
            10 -> 20 [color = 'gray', style = 'dotted']#
            10 -> 9 [color = 'gray', style = 'dotted']#
}#
")
# Figure 4 - article B&W#
library(DiagrammeR)#
grViz("#
#
digraph boxes_and_circles{#
#
    node [shape = box#
            # fixedsize = TRUE#
            # width = 2.5#
            ]#
            1 [label =  <Skates>]#
            2 [label =  <Cetaceans>]#
            3 [label =  <Hooded seals>]#
            4 [label =  <Atlantic cod>]#
            5 [label =  <Grey seals>]#
            6 [label =  <Harp seals>]#
            7 [label =  <Seabirds>]#
            8 [label =  <Harbour seals>]#
            9 [label =  <grayland halibut>]#
            10 [label =  <Piscivorous small<br/>pelagic feeders>]#
            11 [label =  <Redfish>]#
            12 [label =  <Large pelagic<br/>feeders>]#
            13 [label =  <Large demersal<br/>feeders>]#
            14 [label =  <Capelin>]#
            15 [label =  <Small demersal<br/>feeders>]#
            16 [label =  <Planktivorous small<br/>pelagic feeders>]#
            17 [label =  <Small zooplankton>]#
            18 [label =  <Flounders>]#
            19 [label =  <Large crustaceans>]#
            20 [label =  <American plaice>]#
            21 [label =  <Shrimp>]#
#
    edge [dir = back]#
            12 -> 15 [color = 'transparent']#
            12 -> 16 [color = 'transparent']#
            13 -> 15 [color = 'transparent']#
            13 -> 16 [color = 'transparent']#
            20 -> 15 [color = 'transparent']#
            20 -> 16 [color = 'transparent']#
            18 -> 15 [color = 'transparent']#
            18 -> 16 [color = 'transparent']#
            4 -> 15 [color = 'transparent']#
            4 -> 16 [color = 'transparent']#
            15 -> 21 [color = 'transparent']#
            15 -> 19 [color = 'transparent']#
            16 -> 21 [color = 'transparent']#
            16 -> 19 [color = 'transparent']#
#
            2 -> 11 [color = 'transparent']#
            2 -> 1 [color = 'transparent']#
            2 -> 9 [color = 'transparent']#
            3 -> 11 [color = 'transparent']#
            3 -> 1 [color = 'transparent']#
            3 -> 9 [color = 'transparent']#
            5 -> 11 [color = 'transparent']#
            5 -> 1 [color = 'transparent']#
            5 -> 9 [color = 'transparent']#
            6 -> 11 [color = 'transparent']#
            6 -> 1 [color = 'transparent']#
            6 -> 9 [color = 'transparent']#
#
            #Empirical & predictions#
            1 -> 10 [color = 'black', style = 'dashed']#
            2 -> 10 [color = 'black', style = 'dashed']#
            3 -> 10 [color = 'black', style = 'dashed']#
            4 -> 10 [color = 'black', style = 'dashed']#
            6 -> 10 [color = 'black', style = 'dashed']#
            7 -> 10 [color = 'black', style = 'dashed']#
            8 -> 10 [color = 'black', style = 'dashed']#
            10 -> 16 [color = 'black', style = 'dashed']#
            10 -> 14 [color = 'black', style = 'dashed']#
            10 -> 17 [color = 'black', style = 'dashed']#
            12 -> 10 [color = 'black', style = 'dashed']#
            13 -> 10 [color = 'black', style = 'dashed']#
            1 -> 14 [color = 'black', style = 'dashed']#
            2 -> 14 [color = 'black', style = 'dashed']#
            3 -> 14 [color = 'black', style = 'dashed']#
            4 -> 14 [color = 'black', style = 'dashed']#
            5 -> 14 [color = 'black', style = 'dashed']#
            14 -> 17 [color = 'black', style = 'dashed']#
            15 -> 14 [color = 'black', style = 'dashed']#
            6 -> 14 [color = 'black', style = 'dashed']#
            7 -> 14 [color = 'black', style = 'dashed']#
            8 -> 14 [color = 'black', style = 'dashed']#
            9 -> 14 [color = 'black', style = 'dashed']#
            11 -> 14 [color = 'black', style = 'dashed']#
            12 -> 14 [color = 'black', style = 'dashed']#
            13 -> 14 [color = 'black', style = 'dashed']#
#
            # Empirical only#
            5 -> 10 [color = 'black']#
            9 -> 10 [color = 'black']#
            11 -> 10 [color = 'black']#
#
            # Predictions only#
            18 -> 10 [color = 'blue']#
            15 -> 10 [color = 'blue']#
            10 -> 21 [color = 'blue']#
            10 -> 4 [color = 'blue']#
            10 -> 18 [color = 'blue']#
            10 -> 15 [color = 'blue']#
            10 -> 10 [color = 'blue']#
            10 -> 12 [color = 'blue']#
            10 -> 13 [color = 'blue']#
            19 -> 14 [color = 'blue']#
            16 -> 14 [color = 'blue']#
            20 -> 14 [color = 'blue']#
            18 -> 14 [color = 'blue']#
            14 -> 14 [color = 'blue']#
            16 -> 10 [color = 'blue']#
            20 -> 10 [color = 'blue']#
            10 -> 19 [color = 'blue']#
            10 -> 20 [color = 'blue']#
            10 -> 9 [color = 'blue']#
}#
")
# Figure 4 - article couleur#
library(DiagrammeR)#
grViz("#
#
digraph boxes_and_circles{#
#
    node [shape = box#
            # fixedsize = TRUE#
            # width = 2.5#
            ]#
            1 [label =  <Skates>]#
            2 [label =  <Cetaceans>]#
            3 [label =  <Hooded seals>]#
            4 [label =  <Atlantic cod>]#
            5 [label =  <Grey seals>]#
            6 [label =  <Harp seals>]#
            7 [label =  <Seabirds>]#
            8 [label =  <Harbour seals>]#
            9 [label =  <grayland halibut>]#
            10 [label =  <Piscivorous small<br/>pelagic feeders>]#
            11 [label =  <Redfish>]#
            12 [label =  <Large pelagic<br/>feeders>]#
            13 [label =  <Large demersal<br/>feeders>]#
            14 [label =  <Capelin>]#
            15 [label =  <Small demersal<br/>feeders>]#
            16 [label =  <Planktivorous small<br/>pelagic feeders>]#
            17 [label =  <Small zooplankton>]#
            18 [label =  <Flounders>]#
            19 [label =  <Large crustaceans>]#
            20 [label =  <American plaice>]#
            21 [label =  <Shrimp>]#
#
    edge [dir = back]#
            12 -> 15 [color = 'transparent']#
            12 -> 16 [color = 'transparent']#
            13 -> 15 [color = 'transparent']#
            13 -> 16 [color = 'transparent']#
            20 -> 15 [color = 'transparent']#
            20 -> 16 [color = 'transparent']#
            18 -> 15 [color = 'transparent']#
            18 -> 16 [color = 'transparent']#
            4 -> 15 [color = 'transparent']#
            4 -> 16 [color = 'transparent']#
            15 -> 21 [color = 'transparent']#
            15 -> 19 [color = 'transparent']#
            16 -> 21 [color = 'transparent']#
            16 -> 19 [color = 'transparent']#
#
            2 -> 11 [color = 'transparent']#
            2 -> 1 [color = 'transparent']#
            2 -> 9 [color = 'transparent']#
            3 -> 11 [color = 'transparent']#
            3 -> 1 [color = 'transparent']#
            3 -> 9 [color = 'transparent']#
            5 -> 11 [color = 'transparent']#
            5 -> 1 [color = 'transparent']#
            5 -> 9 [color = 'transparent']#
            6 -> 11 [color = 'transparent']#
            6 -> 1 [color = 'transparent']#
            6 -> 9 [color = 'transparent']#
#
            #Empirical & predictions#
            1 -> 10 [color = 'green', style = 'dashed']#
            2 -> 10 [color = 'green', style = 'dashed']#
            3 -> 10 [color = 'green', style = 'dashed']#
            4 -> 10 [color = 'green', style = 'dashed']#
            6 -> 10 [color = 'green', style = 'dashed']#
            7 -> 10 [color = 'green', style = 'dashed']#
            8 -> 10 [color = 'green', style = 'dashed']#
            10 -> 16 [color = 'green', style = 'dashed']#
            10 -> 14 [color = 'green', style = 'dashed']#
            10 -> 17 [color = 'green', style = 'dashed']#
            12 -> 10 [color = 'green', style = 'dashed']#
            13 -> 10 [color = 'green', style = 'dashed']#
            1 -> 14 [color = 'green', style = 'dashed']#
            2 -> 14 [color = 'green', style = 'dashed']#
            3 -> 14 [color = 'green', style = 'dashed']#
            4 -> 14 [color = 'green', style = 'dashed']#
            5 -> 14 [color = 'green', style = 'dashed']#
            14 -> 17 [color = 'green', style = 'dashed']#
            15 -> 14 [color = 'green', style = 'dashed']#
            6 -> 14 [color = 'green', style = 'dashed']#
            7 -> 14 [color = 'green', style = 'dashed']#
            8 -> 14 [color = 'green', style = 'dashed']#
            9 -> 14 [color = 'green', style = 'dashed']#
            11 -> 14 [color = 'green', style = 'dashed']#
            12 -> 14 [color = 'green', style = 'dashed']#
            13 -> 14 [color = 'green', style = 'dashed']#
#
            # Empirical only#
            5 -> 10 [color = 'black']#
            9 -> 10 [color = 'black']#
            11 -> 10 [color = 'black']#
#
            # Predictions only#
            18 -> 10 [color = 'blue']#
            15 -> 10 [color = 'blue']#
            10 -> 21 [color = 'blue']#
            10 -> 4 [color = 'blue']#
            10 -> 18 [color = 'blue']#
            10 -> 15 [color = 'blue']#
            10 -> 10 [color = 'blue']#
            10 -> 12 [color = 'blue']#
            10 -> 13 [color = 'blue']#
            19 -> 14 [color = 'blue']#
            16 -> 14 [color = 'blue']#
            20 -> 14 [color = 'blue']#
            18 -> 14 [color = 'blue']#
            14 -> 14 [color = 'blue']#
            16 -> 10 [color = 'blue']#
            20 -> 10 [color = 'blue']#
            10 -> 19 [color = 'blue']#
            10 -> 20 [color = 'blue']#
            10 -> 9 [color = 'blue']#
}#
")#
# Figure 4 - article B&W#
library(DiagrammeR)#
grViz("#
#
digraph boxes_and_circles{#
#
    node [shape = box#
            # fixedsize = TRUE#
            # width = 2.5#
            ]#
            1 [label =  <Skates>]#
            2 [label =  <Cetaceans>]#
            3 [label =  <Hooded seals>]#
            4 [label =  <Atlantic cod>]#
            5 [label =  <Grey seals>]#
            6 [label =  <Harp seals>]#
            7 [label =  <Seabirds>]#
            8 [label =  <Harbour seals>]#
            9 [label =  <grayland halibut>]#
            10 [label =  <Piscivorous small<br/>pelagic feeders>]#
            11 [label =  <Redfish>]#
            12 [label =  <Large pelagic<br/>feeders>]#
            13 [label =  <Large demersal<br/>feeders>]#
            14 [label =  <Capelin>]#
            15 [label =  <Small demersal<br/>feeders>]#
            16 [label =  <Planktivorous small<br/>pelagic feeders>]#
            17 [label =  <Small zooplankton>]#
            18 [label =  <Flounders>]#
            19 [label =  <Large crustaceans>]#
            20 [label =  <American plaice>]#
            21 [label =  <Shrimp>]#
#
    edge [dir = back]#
            12 -> 15 [color = 'transparent']#
            12 -> 16 [color = 'transparent']#
            13 -> 15 [color = 'transparent']#
            13 -> 16 [color = 'transparent']#
            20 -> 15 [color = 'transparent']#
            20 -> 16 [color = 'transparent']#
            18 -> 15 [color = 'transparent']#
            18 -> 16 [color = 'transparent']#
            4 -> 15 [color = 'transparent']#
            4 -> 16 [color = 'transparent']#
            15 -> 21 [color = 'transparent']#
            15 -> 19 [color = 'transparent']#
            16 -> 21 [color = 'transparent']#
            16 -> 19 [color = 'transparent']#
#
            2 -> 11 [color = 'transparent']#
            2 -> 1 [color = 'transparent']#
            2 -> 9 [color = 'transparent']#
            3 -> 11 [color = 'transparent']#
            3 -> 1 [color = 'transparent']#
            3 -> 9 [color = 'transparent']#
            5 -> 11 [color = 'transparent']#
            5 -> 1 [color = 'transparent']#
            5 -> 9 [color = 'transparent']#
            6 -> 11 [color = 'transparent']#
            6 -> 1 [color = 'transparent']#
            6 -> 9 [color = 'transparent']#
#
            #Empirical & predictions#
            1 -> 10 [color = 'black', style = 'dashed']#
            2 -> 10 [color = 'black', style = 'dashed']#
            3 -> 10 [color = 'black', style = 'dashed']#
            4 -> 10 [color = 'black', style = 'dashed']#
            6 -> 10 [color = 'black', style = 'dashed']#
            7 -> 10 [color = 'black', style = 'dashed']#
            8 -> 10 [color = 'black', style = 'dashed']#
            10 -> 16 [color = 'black', style = 'dashed']#
            10 -> 14 [color = 'black', style = 'dashed']#
            10 -> 17 [color = 'black', style = 'dashed']#
            12 -> 10 [color = 'black', style = 'dashed']#
            13 -> 10 [color = 'black', style = 'dashed']#
            1 -> 14 [color = 'black', style = 'dashed']#
            2 -> 14 [color = 'black', style = 'dashed']#
            3 -> 14 [color = 'black', style = 'dashed']#
            4 -> 14 [color = 'black', style = 'dashed']#
            5 -> 14 [color = 'black', style = 'dashed']#
            14 -> 17 [color = 'black', style = 'dashed']#
            15 -> 14 [color = 'black', style = 'dashed']#
            6 -> 14 [color = 'black', style = 'dashed']#
            7 -> 14 [color = 'black', style = 'dashed']#
            8 -> 14 [color = 'black', style = 'dashed']#
            9 -> 14 [color = 'black', style = 'dashed']#
            11 -> 14 [color = 'black', style = 'dashed']#
            12 -> 14 [color = 'black', style = 'dashed']#
            13 -> 14 [color = 'black', style = 'dashed']#
#
            # Empirical only#
            5 -> 10 [color = 'black']#
            9 -> 10 [color = 'black']#
            11 -> 10 [color = 'black']#
#
            # Predictions only#
            18 -> 10 [color = 'gray']#
            15 -> 10 [color = 'gray']#
            10 -> 21 [color = 'gray']#
            10 -> 4 [color = 'gray']#
            10 -> 18 [color = 'gray']#
            10 -> 15 [color = 'gray']#
            10 -> 10 [color = 'gray']#
            10 -> 12 [color = 'gray']#
            10 -> 13 [color = 'gray']#
            19 -> 14 [color = 'gray']#
            16 -> 14 [color = 'gray']#
            20 -> 14 [color = 'gray']#
            18 -> 14 [color = 'gray']#
            14 -> 14 [color = 'gray']#
            16 -> 10 [color = 'gray']#
            20 -> 10 [color = 'gray']#
            10 -> 19 [color = 'gray']#
            10 -> 20 [color = 'gray']#
            10 -> 9 [color = 'gray']#
}#
")
grViz("#
#
digraph boxes_and_circles{#
#
    node [shape = box#
            # fixedsize = TRUE#
            # width = 2.5#
            ]#
            1 [label =  <Skates>]#
            2 [label =  <Cetaceans>]#
            3 [label =  <Hooded seals>]#
            4 [label =  <Atlantic cod>]#
            5 [label =  <Grey seals>]#
            6 [label =  <Harp seals>]#
            7 [label =  <Seabirds>]#
            8 [label =  <Harbour seals>]#
            9 [label =  <grayland halibut>]#
            10 [label =  <Piscivorous small<br/>pelagic feeders>]#
            11 [label =  <Redfish>]#
            12 [label =  <Large pelagic<br/>feeders>]#
            13 [label =  <Large demersal<br/>feeders>]#
            14 [label =  <Capelin>]#
            15 [label =  <Small demersal<br/>feeders>]#
            16 [label =  <Planktivorous small<br/>pelagic feeders>]#
            17 [label =  <Small zooplankton>]#
            18 [label =  <Flounders>]#
            19 [label =  <Large crustaceans>]#
            20 [label =  <American plaice>]#
            21 [label =  <Shrimp>]#
#
    edge [dir = back]#
            12 -> 15 [color = 'transparent']#
            12 -> 16 [color = 'transparent']#
            13 -> 15 [color = 'transparent']#
            13 -> 16 [color = 'transparent']#
            20 -> 15 [color = 'transparent']#
            20 -> 16 [color = 'transparent']#
            18 -> 15 [color = 'transparent']#
            18 -> 16 [color = 'transparent']#
            4 -> 15 [color = 'transparent']#
            4 -> 16 [color = 'transparent']#
            15 -> 21 [color = 'transparent']#
            15 -> 19 [color = 'transparent']#
            16 -> 21 [color = 'transparent']#
            16 -> 19 [color = 'transparent']#
#
            2 -> 11 [color = 'transparent']#
            2 -> 1 [color = 'transparent']#
            2 -> 9 [color = 'transparent']#
            3 -> 11 [color = 'transparent']#
            3 -> 1 [color = 'transparent']#
            3 -> 9 [color = 'transparent']#
            5 -> 11 [color = 'transparent']#
            5 -> 1 [color = 'transparent']#
            5 -> 9 [color = 'transparent']#
            6 -> 11 [color = 'transparent']#
            6 -> 1 [color = 'transparent']#
            6 -> 9 [color = 'transparent']#
#
            #Empirical & predictions#
            1 -> 10 [color = 'green', style = 'dashed']#
            2 -> 10 [color = 'green', style = 'dashed']#
            3 -> 10 [color = 'green', style = 'dashed']#
            4 -> 10 [color = 'green', style = 'dashed']#
            6 -> 10 [color = 'green', style = 'dashed']#
            7 -> 10 [color = 'green', style = 'dashed']#
            8 -> 10 [color = 'green', style = 'dashed']#
            10 -> 16 [color = 'green', style = 'dashed']#
            10 -> 14 [color = 'green', style = 'dashed']#
            10 -> 17 [color = 'green', style = 'dashed']#
            12 -> 10 [color = 'green', style = 'dashed']#
            13 -> 10 [color = 'green', style = 'dashed']#
            1 -> 14 [color = 'green', style = 'dashed']#
            2 -> 14 [color = 'green', style = 'dashed']#
            3 -> 14 [color = 'green', style = 'dashed']#
            4 -> 14 [color = 'green', style = 'dashed']#
            5 -> 14 [color = 'green', style = 'dashed']#
            14 -> 17 [color = 'green', style = 'dashed']#
            15 -> 14 [color = 'green', style = 'dashed']#
            6 -> 14 [color = 'green', style = 'dashed']#
            7 -> 14 [color = 'green', style = 'dashed']#
            8 -> 14 [color = 'green', style = 'dashed']#
            9 -> 14 [color = 'green', style = 'dashed']#
            11 -> 14 [color = 'green', style = 'dashed']#
            12 -> 14 [color = 'green', style = 'dashed']#
            13 -> 14 [color = 'green', style = 'dashed']#
#
            # Empirical only#
            5 -> 10 [color = 'black']#
            9 -> 10 [color = 'black']#
            11 -> 10 [color = 'black']#
#
            # Predictions only#
            18 -> 10 [color = 'blue', style = 'dotted']#
            15 -> 10 [color = 'blue', style = 'dotted']#
            10 -> 21 [color = 'blue', style = 'dotted']#
            10 -> 4 [color = 'blue', style = 'dotted']#
            10 -> 18 [color = 'blue', style = 'dotted']#
            10 -> 15 [color = 'blue', style = 'dotted']#
            10 -> 10 [color = 'blue', style = 'dotted']#
            10 -> 12 [color = 'blue', style = 'dotted']#
            10 -> 13 [color = 'blue', style = 'dotted']#
            19 -> 14 [color = 'blue', style = 'dotted']#
            16 -> 14 [color = 'blue', style = 'dotted']#
            20 -> 14 [color = 'blue', style = 'dotted']#
            18 -> 14 [color = 'blue', style = 'dotted']#
            14 -> 14 [color = 'blue', style = 'dotted']#
            16 -> 10 [color = 'blue', style = 'dotted']#
            20 -> 10 [color = 'blue', style = 'dotted']#
            10 -> 19 [color = 'blue', style = 'dotted']#
            10 -> 20 [color = 'blue', style = 'dotted']#
            10 -> 9 [color = 'blue', style = 'dotted']#
}#
")#
# Figure 4 - article B&W#
library(DiagrammeR)#
grViz("#
#
digraph boxes_and_circles{#
#
    node [shape = box#
            # fixedsize = TRUE#
            # width = 2.5#
            ]#
            1 [label =  <Skates>]#
            2 [label =  <Cetaceans>]#
            3 [label =  <Hooded seals>]#
            4 [label =  <Atlantic cod>]#
            5 [label =  <Grey seals>]#
            6 [label =  <Harp seals>]#
            7 [label =  <Seabirds>]#
            8 [label =  <Harbour seals>]#
            9 [label =  <grayland halibut>]#
            10 [label =  <Piscivorous small<br/>pelagic feeders>]#
            11 [label =  <Redfish>]#
            12 [label =  <Large pelagic<br/>feeders>]#
            13 [label =  <Large demersal<br/>feeders>]#
            14 [label =  <Capelin>]#
            15 [label =  <Small demersal<br/>feeders>]#
            16 [label =  <Planktivorous small<br/>pelagic feeders>]#
            17 [label =  <Small zooplankton>]#
            18 [label =  <Flounders>]#
            19 [label =  <Large crustaceans>]#
            20 [label =  <American plaice>]#
            21 [label =  <Shrimp>]#
#
    edge [dir = back]#
            12 -> 15 [color = 'transparent']#
            12 -> 16 [color = 'transparent']#
            13 -> 15 [color = 'transparent']#
            13 -> 16 [color = 'transparent']#
            20 -> 15 [color = 'transparent']#
            20 -> 16 [color = 'transparent']#
            18 -> 15 [color = 'transparent']#
            18 -> 16 [color = 'transparent']#
            4 -> 15 [color = 'transparent']#
            4 -> 16 [color = 'transparent']#
            15 -> 21 [color = 'transparent']#
            15 -> 19 [color = 'transparent']#
            16 -> 21 [color = 'transparent']#
            16 -> 19 [color = 'transparent']#
#
            2 -> 11 [color = 'transparent']#
            2 -> 1 [color = 'transparent']#
            2 -> 9 [color = 'transparent']#
            3 -> 11 [color = 'transparent']#
            3 -> 1 [color = 'transparent']#
            3 -> 9 [color = 'transparent']#
            5 -> 11 [color = 'transparent']#
            5 -> 1 [color = 'transparent']#
            5 -> 9 [color = 'transparent']#
            6 -> 11 [color = 'transparent']#
            6 -> 1 [color = 'transparent']#
            6 -> 9 [color = 'transparent']#
#
            #Empirical & predictions#
            1 -> 10 [color = 'black', style = 'dashed']#
            2 -> 10 [color = 'black', style = 'dashed']#
            3 -> 10 [color = 'black', style = 'dashed']#
            4 -> 10 [color = 'black', style = 'dashed']#
            6 -> 10 [color = 'black', style = 'dashed']#
            7 -> 10 [color = 'black', style = 'dashed']#
            8 -> 10 [color = 'black', style = 'dashed']#
            10 -> 16 [color = 'black', style = 'dashed']#
            10 -> 14 [color = 'black', style = 'dashed']#
            10 -> 17 [color = 'black', style = 'dashed']#
            12 -> 10 [color = 'black', style = 'dashed']#
            13 -> 10 [color = 'black', style = 'dashed']#
            1 -> 14 [color = 'black', style = 'dashed']#
            2 -> 14 [color = 'black', style = 'dashed']#
            3 -> 14 [color = 'black', style = 'dashed']#
            4 -> 14 [color = 'black', style = 'dashed']#
            5 -> 14 [color = 'black', style = 'dashed']#
            14 -> 17 [color = 'black', style = 'dashed']#
            15 -> 14 [color = 'black', style = 'dashed']#
            6 -> 14 [color = 'black', style = 'dashed']#
            7 -> 14 [color = 'black', style = 'dashed']#
            8 -> 14 [color = 'black', style = 'dashed']#
            9 -> 14 [color = 'black', style = 'dashed']#
            11 -> 14 [color = 'black', style = 'dashed']#
            12 -> 14 [color = 'black', style = 'dashed']#
            13 -> 14 [color = 'black', style = 'dashed']#
#
            # Empirical only#
            5 -> 10 [color = 'black']#
            9 -> 10 [color = 'black']#
            11 -> 10 [color = 'black']#
#
            # Predictions only#
            18 -> 10 [color = 'gray', style = 'dotted']#
            15 -> 10 [color = 'gray', style = 'dotted']#
            10 -> 21 [color = 'gray', style = 'dotted']#
            10 -> 4 [color = 'gray', style = 'dotted']#
            10 -> 18 [color = 'gray', style = 'dotted']#
            10 -> 15 [color = 'gray', style = 'dotted']#
            10 -> 10 [color = 'gray', style = 'dotted']#
            10 -> 12 [color = 'gray', style = 'dotted']#
            10 -> 13 [color = 'gray', style = 'dotted']#
            19 -> 14 [color = 'gray', style = 'dotted']#
            16 -> 14 [color = 'gray', style = 'dotted']#
            20 -> 14 [color = 'gray', style = 'dotted']#
            18 -> 14 [color = 'gray', style = 'dotted']#
            14 -> 14 [color = 'gray', style = 'dotted']#
            16 -> 10 [color = 'gray', style = 'dotted']#
            20 -> 10 [color = 'gray', style = 'dotted']#
            10 -> 19 [color = 'gray', style = 'dotted']#
            10 -> 20 [color = 'gray', style = 'dotted']#
            10 -> 9 [color = 'gray', style = 'dotted']#
}#
")
